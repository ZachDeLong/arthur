

# Implementation Plan: Google OAuth Login for CounselorSophie

## Overview

Add Google OAuth as an alternative login method. This involves:
1. Supabase Auth configuration for Google provider
2. OAuth callback route handler
3. "Sign in with Google" button on login/signup pages
4. Automatic profile creation on first Google sign-in
5. Auth state handling for OAuth flows

---

## Step 1: Supabase Dashboard Configuration (Manual)

Before any code changes, configure Google OAuth in the Supabase dashboard:

1. **Google Cloud Console:**
   - Go to https://console.cloud.google.com/apis/credentials
   - Create OAuth 2.0 Client ID (Web application)
   - Add authorized redirect URI: `https://<SUPABASE_PROJECT_REF>.supabase.co/auth/v1/callback`
   - Also add for local dev: `http://localhost:54321/auth/v1/callback` (if using local Supabase)
   - Copy the **Client ID** and **Client Secret**

2. **Supabase Dashboard:**
   - Go to Authentication → Providers → Google
   - Enable Google provider
   - Paste Client ID and Client Secret
   - Save

No new environment variables are needed in `.env.local` — the Google OAuth config lives in Supabase's dashboard, and the existing `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` are sufficient.

---

## Step 2: Create OAuth Callback Route

**File: `app/auth/callback/route.ts`** (NEW)

This handles the redirect from Supabase after Google OAuth. Note this is **outside** the `(auth)` route group since it's an API route handler, not a page.

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function GET(request: NextRequest) {
  const requestUrl = new URL(request.url)
  const code = requestUrl.searchParams.get('code')
  const next = requestUrl.searchParams.get('next') ?? '/dashboard'

  if (code) {
    const cookieStore = await cookies()

    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return cookieStore.getAll()
          },
          setAll(cookiesToSet) {
            try {
              cookiesToSet.forEach(({ name, value, options }) => {
                cookieStore.set(name, value, options)
              })
            } catch {
              // The `setAll` method was called from a Server Component.
              // This can be ignored if you have middleware refreshing sessions.
            }
          },
        },
      }
    )

    const { error } = await supabase.auth.exchangeCodeForSession(code)

    if (!error) {
      return NextResponse.redirect(new URL(next, requestUrl.origin))
    }
  }

  // If there's an error or no code, redirect to login with error
  return NextResponse.redirect(
    new URL('/login?error=Could+not+authenticate+with+Google', requestUrl.origin)
  )
}
```

---

## Step 3: Create Profile on First OAuth Sign-In

**File: `app/api/auth/ensure-profile/route.ts`** (NEW)

This API route uses the service role client to create a profile and student record if they don't exist yet. It's called client-side after OAuth login completes.

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function POST(request: NextRequest) {
  const cookieStore = await cookies()

  // Create a user-scoped client to get the authenticated user
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => {
              cookieStore.set(name, value, options)
            })
          } catch {
            // Ignored in Server Component context
          }
        },
      },
    }
  )

  const {
    data: { user },
    error: userError,
  } = await supabase.auth.getUser()

  if (userError || !user) {
    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })
  }

  // Use service role client to bypass RLS for profile creation
  const serviceClient = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )

  // Check if profile already exists
  const { data: existingProfile } = await serviceClient
    .from('profiles')
    .select('id')
    .eq('id', user.id)
    .single()

  if (existingProfile) {
    return NextResponse.json({ message: 'Profile already exists', profileId: existingProfile.id })
  }

  // Extract name from Google OAuth metadata
  const fullName = user.user_metadata?.full_name || user.user_metadata?.name || ''
  const email = user.email || ''
  const avatarUrl = user.user_metadata?.avatar_url || null
  const nameParts = fullName.split(' ')
  const firstName = nameParts[0] || ''
  const lastName = nameParts.slice(1).join(' ') || ''

  // Create profile
  const { data: profile, error: profileError } = await serviceClient
    .from('profiles')
    .insert({
      id: user.id,
      email,
      first_name: firstName,
      last_name: lastName,
      avatar_url: avatarUrl,
      role: 'student',
    })
    .select('id')
    .single()

  if (profileError) {
    console.error('Error creating profile:', profileError)
    return NextResponse.json({ error: 'Failed to create profile' }, { status: 500 })
  }

  // Create student record linked to profile
  const { data: student, error: studentError } = await serviceClient
    .from('students')
    .insert({
      profile_id: user.id,
      first_name: firstName,
      last_name: lastName,
      email,
    })
    .select('id')
    .single()

  if (studentError) {
    console.error('Error creating student:', studentError)
    return NextResponse.json({ error: 'Failed to create student record' }, { status: 500 })
  }

  return NextResponse.json({
    message: 'Profile created',
    profileId: profile.id,
    studentId: student.id,
  })
}
```

---

## Step 4: Create Google OAuth Button Component

**File: `components/auth/GoogleSignInButton.tsx`** (NEW)

```typescript
'use client'

import { useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { Button } from '@/components/ui/button'

export function GoogleSignInButton() {
  const [isLoading, setIsLoading] = useState(false)

  const handleGoogleSignIn = async () => {
    setIsLoading(true)

    try {
      const supabase = createClient()

      const { error } = await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: `${window.location.origin}/auth/callback?next=/dashboard`,
          queryParams: {
            access_type: 'offline',
            prompt: 'consent',
          },
        },
      })

      if (error) {
        console.error('Google sign-in error:', error)
        setIsLoading(false)
      }
      // If no error, the browser will redirect to Google
    } catch (err) {
      console.error('Google sign-in error:', err)
      setIsLoading(false)
    }
  }

  return (
    <Button
      type="button"
      variant="outline"
      className="w-full flex items-center justify-center gap-3"
      onClick={handleGoogleSignIn}
      disabled={isLoading}
    >
      {isLoading ? (
        <div className="h-5 w-5 animate-spin rounded-full border-2 border-gray-300 border-t-gray-600" />
      ) : (
        <svg className="h-5 w-5" viewBox="0 0 24 24">
          <path
            d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"
            fill="#4285F4"
          />
          <path
            d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
            fill="#34A853"
          />
          <path
            d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
            fill="#FBBC05"
          />
          <path
            d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
            fill="#EA4335"
          />
        </svg>
      )}
      {isLoading ? 'Signing in...' : 'Continue with Google'}
    </Button>
  )
}
```

---

## Step 5: Modify Login Page

**File: `app/(auth)/login/page.tsx`** (MODIFY)

Add the Google sign-in button with a divider. Insert these changes into the existing login page:

```typescript
// Add import at top of file
import { GoogleSignInButton } from '@/components/auth/GoogleSignInButton'

// Add inside the form card, ABOVE the existing email/password form:
// (After the heading, before the <form> tag)

{/* Google OAuth */}
<GoogleSignInButton />

{/* Divider */}
<div className="relative my-6">
  <div className="absolute inset-0 flex items-center">
    <span className="w-full border-t border-gray-300" />
  </div>
  <div className="relative flex justify-center text-sm">
    <span className="bg-white px-2 text-gray-500">Or continue with email</span>
  </div>
</div>

{/* Existing email/password form below */}
```

Also add error display for OAuth errors from the URL params:

```typescript
'use client'

import { useSearchParams } from 'next/navigation'

// Inside the component:
const searchParams = useSearchParams()
const oauthError = searchParams.get('error')

// In the JSX, above the GoogleSignInButton:
{oauthError && (
  <div className="mb-4 rounded-md bg-red-50 p-3 text-sm text-red-600">
    {decodeURIComponent(oauthError)}
  </div>
)}
```

---

## Step 6: Modify Signup Page

**File: `app/(auth)/signup/page.tsx`** (MODIFY)

Same pattern as the login page — add Google button and divider:

```typescript
// Add import at top
import { GoogleSignInButton } from '@/components/auth/GoogleSignInButton'

// Add inside the form card, above the signup form:

{/* Google OAuth */}
<GoogleSignInButton />

{/* Divider */}
<div className="relative my-6">
  <div className="absolute inset-0 flex items-center">
    <span className="w-full border-t border-gray-300" />
  </div>
  <div className="relative flex justify-center text-sm">
    <span className="bg-white px-2 text-gray-500">Or sign up with email</span>
  </div>
</div>

{/* Existing signup form below */}
```

---

## Step 7: Update AuthContext to Handle OAuth Profile Creation

**File: `contexts/AuthContext.tsx`** (MODIFY)

After the OAuth redirect, the user arrives at `/dashboard` but may not have a profile yet. Update the AuthContext to detect first-time OAuth users and call the ensure-profile endpoint.

```typescript
// Add this function inside AuthProvider, after the user state is set:

import { useCallback, useEffect, useRef, useState } from 'react'

// Inside AuthProvider component:
const profileEnsured = useRef(false)

const ensureProfile = useCallback(async (user: User) => {
  if (profileEnsured.current) return
  profileEnsured.current = true

  // Only call for OAuth users (they have provider info in app_metadata)
  const provider = user.app_metadata?.provider
  if (provider && provider !== 'email') {
    try {
      await fetch('/api/auth/ensure-profile', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      })
    } catch (err) {
      console.error('Failed to ensure profile:', err)
    }
  }
}, [])

// In the onAuthStateChange callback, after setting the user:
// Find the existing INITIAL_SESSION or SIGNED_IN handling and add:

useEffect(() => {
  const supabase = createClient()

  const {
    data: { subscription },
  } = supabase.auth.onAuthStateChange(async (event, session) => {
    const currentUser = session?.user ?? null
    setUser(currentUser)

    if (event === 'SIGNED_IN' && currentUser) {
      // Ensure profile exists for OAuth users
      await ensureProfile(currentUser)
    }

    if (event === 'INITIAL_SESSION' && currentUser) {
      // Also check on initial session load (page refresh after OAuth)
      await ensureProfile(currentUser)
    }

    // ... existing redirect logic ...
  })

  return () => subscription.unsubscribe()
}, [ensureProfile])
```

---

## Step 8: Update Supabase Middleware/Proxy for OAuth Cookies

**File: `lib/supabase/middleware.ts`** (MODIFY)

Ensure the middleware properly handles the cookie exchange during OAuth callback. The existing middleware likely already does this, but verify it handles the `code` exchange path:

```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // IMPORTANT: Do NOT add conditions that skip this for the callback route.
  // The session must be refreshed for all routes.
  await supabase.auth.getUser()

  return supabaseResponse
}
```

---

## Step 9: Update `proxy.ts` to Allow Callback Route

**File: `proxy.ts`** (MODIFY)

Ensure the auth callback route is not blocked or redirected by the proxy. If the proxy has path checks, add `/auth/callback` to allowed public paths:

```typescript
// In the proxy/middleware config, ensure these paths are public:
const publicPaths = ['/login', '/signup', '/reset-password', '/auth/callback']

// If there's a matcher in middleware config, update it:
export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization)
     * - favicon.ico
     * - public folder
     * - auth/callback (OAuth callback)
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

---

## File Summary

| File | Action | Purpose |
|------|--------|---------|
| `app/auth/callback/route.ts` | **CREATE** | OAuth callback handler — exchanges code for session |
| `app/api/auth/ensure-profile/route.ts` | **CREATE** | Creates profile + student record for first-time OAuth users |
| `components/auth/GoogleSignInButton.tsx` | **CREATE** | Reusable Google sign-in button with loading state |
| `app/(auth)/login/page.tsx` | **MODIFY** | Add Google button, divider, OAuth error display |
| `app/(auth)/signup/page.tsx` | **MODIFY** | Add Google button, divider |
| `contexts/AuthContext.tsx` | **MODIFY** | Call ensure-profile after OAuth sign-in |
| `lib/supabase/middleware.ts` | **VERIFY** | Ensure cookie handling works for OAuth flow |
| `proxy.ts` | **VERIFY** | Ensure `/auth/callback` is accessible |

---

## Database Tables Referenced

| Table | Columns Used | Operation |
|-------|-------------|-----------|
| `profiles` | `id`, `email`, `first_name`, `last_name`, `avatar_url`, `role` | SELECT (check exists), INSERT |
| `students` | `id`, `profile_id`, `first_name`, `last_name`, `email` | INSERT |

---

## Testing Checklist

1. **Happy path:** Click "Continue with Google" → redirected to Google → consent → redirected back → `/dashboard` loads with profile created
2. **Returning user:** Click "Continue with Google" → already consented → redirected back → existing profile untouched
3. **Error handling:** Cancel Google consent → redirected to `/login` with error message
4. **Page refresh:** After OAuth login, refreshing `/dashboard` doesn't re-create profile (idempotent)
5. **Existing email user:** If a user already signed up with email, signing in with Google (same email) should link accounts (Supabase default behavior when email is confirmed)
6. **Build check:** `npm run build` and `npx tsc --noEmit` pass without errors