

# Implementation Plan: Essay Draft Storage with Version History

## Overview

Add a complete essay management system where students can write, save, and version-control their college application essays. Essays can be linked to specific colleges (supplements) or be general (Common App, personal statement). Every save creates an immutable version, and students can browse history and diff any two versions.

---

## 1. Database Schema

### 1.1 Create Migration SQL

**File: `supabase/migrations/20250101000000_essay_drafts.sql`** (run via Supabase Dashboard SQL Editor or CLI)

```sql
-- ============ ESSAY DRAFTS TABLE ============
CREATE TABLE essay_drafts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  student_id UUID NOT NULL REFERENCES students(id) ON DELETE CASCADE,
  college_id UUID REFERENCES saved_colleges(id) ON DELETE SET NULL,
  essay_type TEXT NOT NULL DEFAULT 'common_app',
  -- essay_type: 'common_app', 'personal_statement', 'supplement', 'why_us', 'additional_info', 'other'
  title TEXT NOT NULL,
  prompt TEXT,
  word_limit INTEGER,
  status TEXT NOT NULL DEFAULT 'draft',
  -- status: 'draft', 'in_review', 'final'
  current_version_number INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============ ESSAY VERSIONS TABLE ============
CREATE TABLE essay_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  essay_draft_id UUID NOT NULL REFERENCES essay_drafts(id) ON DELETE CASCADE,
  version_number INTEGER NOT NULL,
  content TEXT NOT NULL DEFAULT '',
  word_count INTEGER NOT NULL DEFAULT 0,
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(essay_draft_id, version_number)
);

-- ============ INDEXES ============
CREATE INDEX idx_essay_drafts_student_id ON essay_drafts(student_id);
CREATE INDEX idx_essay_drafts_college_id ON essay_drafts(college_id);
CREATE INDEX idx_essay_versions_essay_draft_id ON essay_versions(essay_draft_id);
CREATE INDEX idx_essay_versions_draft_version ON essay_versions(essay_draft_id, version_number DESC);

-- ============ RLS POLICIES ============
ALTER TABLE essay_drafts ENABLE ROW LEVEL SECURITY;
ALTER TABLE essay_versions ENABLE ROW LEVEL SECURITY;

-- essay_drafts policies
CREATE POLICY "Users can view own essay drafts"
  ON essay_drafts FOR SELECT
  USING (has_student_access(student_id));

CREATE POLICY "Users can insert own essay drafts"
  ON essay_drafts FOR INSERT
  WITH CHECK (has_student_access(student_id));

CREATE POLICY "Users can update own essay drafts"
  ON essay_drafts FOR UPDATE
  USING (has_student_access(student_id));

CREATE POLICY "Users can delete own essay drafts"
  ON essay_drafts FOR DELETE
  USING (has_student_access(student_id));

-- essay_versions policies
CREATE POLICY "Users can view own essay versions"
  ON essay_versions FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM essay_drafts
      WHERE essay_drafts.id = essay_versions.essay_draft_id
      AND has_student_access(essay_drafts.student_id)
    )
  );

CREATE POLICY "Users can insert own essay versions"
  ON essay_versions FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM essay_drafts
      WHERE essay_drafts.id = essay_versions.essay_draft_id
      AND has_student_access(essay_drafts.student_id)
    )
  );

-- ============ UPDATED_AT TRIGGER ============
CREATE TRIGGER update_essay_drafts_updated_at
  BEFORE UPDATE ON essay_drafts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

---

## 2. Zod Schemas & Types

### 2.1 Update `lib/schemas.ts`

Add to the existing schemas file:

```typescript
// ============ ESSAY SCHEMAS ============

export const EssayTypeEnum = z.enum([
  'common_app',
  'personal_statement',
  'supplement',
  'why_us',
  'additional_info',
  'other',
])

export const EssayStatusEnum = z.enum(['draft', 'in_review', 'final'])

export const EssayDraftSchema = z.object({
  id: z.string().uuid(),
  student_id: z.string().uuid(),
  college_id: z.string().uuid().nullable(),
  essay_type: EssayTypeEnum,
  title: z.string().min(1, 'Title is required'),
  prompt: z.string().nullable(),
  word_limit: z.number().int().positive().nullable(),
  status: EssayStatusEnum,
  current_version_number: z.number().int().min(0),
  created_at: z.string(),
  updated_at: z.string(),
})

export const EssayVersionSchema = z.object({
  id: z.string().uuid(),
  essay_draft_id: z.string().uuid(),
  version_number: z.number().int().min(1),
  content: z.string(),
  word_count: z.number().int().min(0),
  notes: z.string().nullable(),
  created_at: z.string(),
})

export const CreateEssayDraftRequestSchema = z.object({
  student_id: z.string().uuid(),
  college_id: z.string().uuid().nullable().optional(),
  essay_type: EssayTypeEnum,
  title: z.string().min(1, 'Title is required'),
  prompt: z.string().optional(),
  word_limit: z.number().int().positive().optional(),
})

export const SaveEssayVersionRequestSchema = z.object({
  essay_draft_id: z.string().uuid(),
  content: z.string(),
  notes: z.string().optional(),
})

export const UpdateEssayDraftRequestSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).optional(),
  prompt: z.string().optional(),
  word_limit: z.number().int().positive().nullable().optional(),
  status: EssayStatusEnum.optional(),
  essay_type: EssayTypeEnum.optional(),
  college_id: z.string().uuid().nullable().optional(),
})

export type EssayDraft = z.infer<typeof EssayDraftSchema>
export type EssayVersion = z.infer<typeof EssayVersionSchema>
export type CreateEssayDraftRequest = z.infer<typeof CreateEssayDraftRequestSchema>
export type SaveEssayVersionRequest = z.infer<typeof SaveEssayVersionRequestSchema>
export type UpdateEssayDraftRequest = z.infer<typeof UpdateEssayDraftRequestSchema>

// Extended type with joined data
export type EssayDraftWithVersions = EssayDraft & {
  essay_versions: EssayVersion[]
  saved_colleges?: { id: string; college_name: string } | null
}
```

---

## 3. Database Operations

### 3.1 Create `lib/essay-db.ts`

```typescript
import { createClient } from '@/lib/supabase/client'
import type {
  EssayDraft,
  EssayVersion,
  EssayDraftWithVersions,
  CreateEssayDraftRequest,
  SaveEssayVersionRequest,
  UpdateEssayDraftRequest,
} from '@/lib/schemas'

// ============ FETCH ESSAY DRAFTS ============

export async function fetchEssayDrafts(studentId: string): Promise<EssayDraftWithVersions[]> {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('essay_drafts')
    .select(
      `
      *,
      essay_versions (id, essay_draft_id, version_number, word_count, notes, created_at),
      saved_colleges (id, college_name)
    `
    )
    .eq('student_id', studentId)
    .order('updated_at', { ascending: false })

  if (error) throw error
  return (data ?? []) as EssayDraftWithVersions[]
}

// ============ FETCH SINGLE ESSAY DRAFT WITH ALL VERSIONS ============

export async function fetchEssayDraft(essayDraftId: string): Promise<EssayDraftWithVersions> {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('essay_drafts')
    .select(
      `
      *,
      essay_versions (*),
      saved_colleges (id, college_name)
    `
    )
    .eq('id', essayDraftId)
    .single()

  if (error) throw error
  return data as EssayDraftWithVersions
}

// ============ FETCH ESSAY VERSION CONTENT ============

export async function fetchEssayVersion(versionId: string): Promise<EssayVersion> {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('essay_versions')
    .select('*')
    .eq('id', versionId)
    .single()

  if (error) throw error
  return data as EssayVersion
}

// ============ FETCH VERSION BY NUMBER ============

export async function fetchEssayVersionByNumber(
  essayDraftId: string,
  versionNumber: number
): Promise<EssayVersion> {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('essay_versions')
    .select('*')
    .eq('essay_draft_id', essayDraftId)
    .eq('version_number', versionNumber)
    .single()

  if (error) throw error
  return data as EssayVersion
}

// ============ CREATE ESSAY DRAFT ============

export async function createEssayDraft(input: CreateEssayDraftRequest): Promise<EssayDraft> {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('essay_drafts')
    .insert({
      student_id: input.student_id,
      college_id: input.college_id ?? null,
      essay_type: input.essay_type,
      title: input.title,
      prompt: input.prompt ?? null,
      word_limit: input.word_limit ?? null,
      status: 'draft',
      current_version_number: 0,
    })
    .select()
    .single()

  if (error) throw error
  return data as EssayDraft
}

// ============ SAVE NEW VERSION ============

export async function saveEssayVersion(input: SaveEssayVersionRequest): Promise<EssayVersion> {
  const supabase = createClient()

  // Get current version number
  const { data: draft, error: draftError } = await supabase
    .from('essay_drafts')
    .select('current_version_number')
    .eq('id', input.essay_draft_id)
    .single()

  if (draftError) throw draftError

  const newVersionNumber = (draft.current_version_number ?? 0) + 1
  const wordCount = input.content
    .trim()
    .split(/\s+/)
    .filter((w) => w.length > 0).length

  // Insert new version
  const { data: version, error: versionError } = await supabase
    .from('essay_versions')
    .insert({
      essay_draft_id: input.essay_draft_id,
      version_number: newVersionNumber,
      content: input.content,
      word_count: wordCount,
      notes: input.notes ?? null,
    })
    .select()
    .single()

  if (versionError) throw versionError

  // Update draft's current version number and updated_at
  const { error: updateError } = await supabase
    .from('essay_drafts')
    .update({ current_version_number: newVersionNumber })
    .eq('id', input.essay_draft_id)

  if (updateError) throw updateError

  return version as EssayVersion
}

// ============ UPDATE ESSAY DRAFT METADATA ============

export async function updateEssayDraft(input: UpdateEssayDraftRequest): Promise<EssayDraft> {
  const supabase = createClient()
  const { id, ...updates } = input

  const { data, error } = await supabase
    .from('essay_drafts')
    .update(updates)
    .eq('id', id)
    .select()
    .single()

  if (error) throw error
  return data as EssayDraft
}

// ============ DELETE ESSAY DRAFT ============

export async function deleteEssayDraft(essayDraftId: string): Promise<void> {
  const supabase = createClient()
  const { error } = await supabase.from('essay_drafts').delete().eq('id', essayDraftId)

  if (error) throw error
}
```

---

## 4. TanStack Query Hooks

### 4.1 Create `hooks/useEssays.ts`

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import {
  fetchEssayDrafts,
  fetchEssayDraft,
  fetchEssayVersion,
  fetchEssayVersionByNumber,
  createEssayDraft,
  saveEssayVersion,
  updateEssayDraft,
  deleteEssayDraft,
} from '@/lib/essay-db'
import type {
  CreateEssayDraftRequest,
  SaveEssayVersionRequest,
  UpdateEssayDraftRequest,
  EssayDraftWithVersions,
} from '@/lib/schemas'

// ============ QUERY KEYS ============

export const essayKeys = {
  all: ['essays'] as const,
  lists: () => [...essayKeys.all, 'list'] as const,
  list: (studentId: string) => [...essayKeys.lists(), studentId] as const,
  details: () => [...essayKeys.all, 'detail'] as const,
  detail: (essayDraftId: string) => [...essayKeys.details(), essayDraftId] as const,
  versions: () => [...essayKeys.all, 'version'] as const,
  version: (versionId: string) => [...essayKeys.versions(), versionId] as const,
  versionByNumber: (essayDraftId: string, versionNumber: number) =>
    [...essayKeys.versions(), essayDraftId, versionNumber] as const,
}

// ============ QUERIES ============

export function useEssayDrafts(studentId: string | undefined) {
  return useQuery({
    queryKey: essayKeys.list(studentId ?? ''),
    queryFn: () => fetchEssayDrafts(studentId!),
    enabled: !!studentId,
  })
}

export function useEssayDraft(essayDraftId: string | undefined) {
  return useQuery({
    queryKey: essayKeys.detail(essayDraftId ?? ''),
    queryFn: () => fetchEssayDraft(essayDraftId!),
    enabled: !!essayDraftId,
  })
}

export function useEssayVersion(versionId: string | undefined) {
  return useQuery({
    queryKey: essayKeys.version(versionId ?? ''),
    queryFn: () => fetchEssayVersion(versionId!),
    enabled: !!versionId,
  })
}

export function useEssayVersionByNumber(
  essayDraftId: string | undefined,
  versionNumber: number | undefined
) {
  return useQuery({
    queryKey: essayKeys.versionByNumber(essayDraftId ?? '', versionNumber ?? 0),
    queryFn: () => fetchEssayVersionByNumber(essayDraftId!, versionNumber!),
    enabled: !!essayDraftId && versionNumber !== undefined && versionNumber > 0,
  })
}

// ============ MUTATIONS ============

export function useCreateEssayDraft(studentId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (input: CreateEssayDraftRequest) => createEssayDraft(input),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: essayKeys.list(studentId) })
    },
  })
}

export function useSaveEssayVersion(studentId: string, essayDraftId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (input: SaveEssayVersionRequest) => saveEssayVersion(input),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: essayKeys.detail(essayDraftId) })
      queryClient.invalidateQueries({ queryKey: essayKeys.list(studentId) })
    },
  })
}

export function useUpdateEssayDraft(studentId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (input: UpdateEssayDraftRequest) => updateEssayDraft(input),
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: essayKeys.detail(data.id) })
      queryClient.invalidateQueries({ queryKey: essayKeys.list(studentId) })
    },
  })
}

export function useDeleteEssayDraft(studentId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (essayDraftId: string) => deleteEssayDraft(essayDraftId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: essayKeys.list(studentId) })
    },
  })
}
```

---

## 5. Zustand Store Extensions

### 5.1 Update `store/index.ts`

Add essay-related UI state to the existing store:

```typescript
// Add to existing store interface
interface AppState {
  // ... existing state ...

  // ============ ESSAY STATE ============
  activeEssayId: string | null
  setActiveEssayId: (id: string | null) => void
  essayDiffLeft: number | null
  essayDiffRight: number | null
  setEssayDiffVersions: (left: number | null, right: number | null) => void
  showEssayVersionHistory: boolean
  setShowEssayVersionHistory: (show: boolean) => void
}

// Add to create() inside the store:
// ============ ESSAY STATE ============
activeEssayId: null,
setActiveEssayId: (id) => set({ activeEssayId: id }),
essayDiffLeft: null,
essayDiffRight: null,
setEssayDiffVersions: (left, right) => set({ essayDiffLeft: left, essayDiffRight: right }),
showEssayVersionHistory: false,
setShowEssayVersionHistory: (show) => set({ showEssayVersionHistory: show }),

// Add granular selectors:
export const useActiveEssayId = () => useStore((s) => s.activeEssayId)
export const useSetActiveEssayId = () => useStore((s) => s.setActiveEssayId)
export const useEssayDiffLeft = () => useStore((s) => s.essayDiffLeft)
export const useEssayDiffRight = () => useStore((s) => s.essayDiffRight)
export const useSetEssayDiffVersions = () => useStore((s) => s.setEssayDiffVersions)
export const useShowEssayVersionHistory = () => useStore((s) => s.showEssayVersionHistory)
export const useSetShowEssayVersionHistory = () => useStore((s) => s.setShowEssayVersionHistory)
```

---

## 6. Diff Utility

### 6.1 Create `lib/diff.ts`

```typescript
// ============ TEXT DIFF UTILITY ============
// Simple line-based diff using Myers algorithm (no external dependency)

export type DiffLine = {
  type: 'added' | 'removed' | 'unchanged'
  content: string
  lineNumber?: number
}

export function computeDiff(oldText: string, newText: string): DiffLine[] {
  const oldLines = oldText.split('\n')
  const newLines = newText.split('\n')

  const result: DiffLine[] = []

  // Simple LCS-based diff
  const lcs = buildLCSTable(oldLines, newLines)
  backtrackDiff(lcs, oldLines, newLines, oldLines.length, newLines.length, result)

  return result
}

function buildLCSTable(a: string[], b: string[]): number[][] {
  const m = a.length
  const n = b.length
  const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0))

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (a[i - 1] === b[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }

  return dp
}

function backtrackDiff(
  dp: number[][],
  a: string[],
  b: string[],
  i: number,
  j: number,
  result: DiffLine[]
): void {
  if (i === 0 && j === 0) return

  if (i > 0 && j > 0 && a[i - 1] === b[j - 1]) {
    backtrackDiff(dp, a, b, i - 1, j - 1, result)
    result.push({ type: 'unchanged', content: a[i - 1] })
  } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
    backtrackDiff(dp, a, b, i, j - 1, result)
    result.push({ type: 'added', content: b[j - 1] })
  } else if (i > 0) {
    backtrackDiff(dp, a, b, i - 1, j, result)
    result.push({ type: 'removed', content: a[i - 1] })
  }
}

// ============ WORD COUNT UTILITY ============

export function countWords(text: string): number {
  return text
    .trim()
    .split(/\s+/)
    .filter((w) => w.length > 0).length
}

// ============ DIFF STATS ============

export function getDiffStats(diff: DiffLine[]) {
  const added = diff.filter((l) => l.type === 'added').length
  const removed = diff.filter((l) => l.type === 'removed').length
  const unchanged = diff.filter((l) => l.type === 'unchanged').length
  return { added, removed, unchanged }
}
```

---

## 7. Components

### 7.1 Create `components/essays/EssayList.tsx`

```tsx
'use client'

import React, { useMemo, useState } from 'react'
import { Plus, FileText, Trash2, GraduationCap, PenLine } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { cn } from '@/lib/utils'
import type { EssayDraftWithVersions } from '@/lib/schemas'

// ============ TYPES ============

interface EssayListProps {
  essays: EssayDraftWithVersions[]
  activeEssayId: string | null
  onSelectEssay: (id: string) => void
  onCreateEssay: () => void
  onDeleteEssay: (id: string) => void
  isDeleting: boolean
}

// ============ CONSTANTS ============

const ESSAY_TYPE_LABELS: Record<string, string> = {
  common_app: 'Common App',
  personal_statement: 'Personal Statement',
  supplement: 'Supplement',
  why_us: 'Why Us',
  additional_info: 'Additional Info',
  other: 'Other',
}

const STATUS_COLORS: Record<string, string> = {
  draft: 'bg-yellow-100 text-yellow-800',
  in_review: 'bg-blue-100 text-blue-800',
  final: 'bg-green-100 text-green-800',
}

// ============ COMPONENT ============

const EssayList = React.memo(function EssayList({
  essays,
  activeEssayId,
  onSelectEssay,
  onCreateEssay,
  onDeleteEssay,
  isDeleting,
}: EssayListProps) {
  const [filter, setFilter] = useState<string>('all')

  const filteredEssays = useMemo(() => {
    if (filter === 'all') return essays
    return essays.filter((e) => e.essay_type === filter)
  }, [essays, filter])

  const essayTypes = useMemo(() => {
    const types = new Set(essays.map((e) => e.essay_type))
    return Array.from(types)
  }, [essays])

  return (
    <div className="flex h-full flex-col">
      <div className="flex items-center justify-between border-b p-4">
        <h2 className="text-lg font-semibold">Essays</h2>
        <Button size="sm" onClick={onCreateEssay}>
          <Plus className="mr-1 h-4 w-4" />
          New
        </Button>
      </div>

      {/* Filter Tabs */}
      {essayTypes.length > 1 && (
        <div className="flex gap-1 overflow-x-auto border-b px-4 py-2">
          <Badge
            variant={filter === 'all' ? 'default' : 'outline'}
            className="cursor-pointer whitespace-nowrap"
            onClick={() => setFilter('all')}
          >
            All ({essays.length})
          </Badge>
          {essayTypes.map((type) => (
            <Badge
              key={type}
              variant={filter === type ? 'default' : 'outline'}
              className="cursor-pointer whitespace-nowrap"
              onClick={() => setFilter(type)}
            >
              {ESSAY_TYPE_LABELS[type] ?? type}
            </Badge>
          ))}
        </div>
      )}

      {/* Essay Cards */}
      <div className="flex-1 space-y-2 overflow-y-auto p-4">
        {filteredEssays.length === 0 ? (
          <div className="py-8 text-center text-sm text-muted-foreground">
            <FileText className="mx-auto mb-2 h-8 w-8 opacity-50" />
            <p>No essays yet. Create your first one!</p>
          </div>
        ) : (
          filteredEssays.map((essay) => {
            const latestVersion = essay.essay_versions?.sort(
              (a, b) => b.version_number - a.version_number
            )[0]

            return (
              <Card
                key={essay.id}
                className={cn(
                  'cursor-pointer transition-colors hover:bg-accent/50',
                  activeEssayId === essay.id && 'border-primary bg-accent'
                )}
                onClick={() => onSelectEssay(essay.id)}
              >
                <CardContent className="p-3">
                  <div className="flex items-start justify-between">
                    <div className="min-w-0 flex-1">
                      <p className="truncate text-sm font-medium">{essay.title}</p>
                      <div className="mt-1 flex items-center gap-2">
                        <Badge variant="outline" className="text-xs">
                          {ESSAY_TYPE_LABELS[essay.essay_type] ?? essay.essay_type}
                        </Badge>
                        <Badge className={cn('text-xs', STATUS_COLORS[essay.status])}>
                          {essay.status.replace('_', ' ')}
                        </Badge>
                      </div>
                      {essay.saved_colleges && (
                        <p className="mt-1 flex items-center gap-1 text-xs text-muted-foreground">
                          <GraduationCap className="h-3 w-3" />
                          {essay.saved_colleges.college_name}
                        </p>
                      )}
                      <div className="mt-1 flex items-center gap-2 text-xs text-muted-foreground">
                        <span>v{essay.current_version_number}</span>
                        {latestVersion && <span>â€¢ {latestVersion.word_count} words</span>}
                        {essay.word_limit && (
                          <span>/ {essay.word_limit}</span>
                        )}
                      </div>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-8 w-8 shrink-0"
                      onClick={(e) => {
                        e.stopPropagation()
                        onDeleteEssay(essay.id)
                      }}
                      disabled={isDeleting}
                    >
                      <Trash2 className="h-4 w-4 text-destructive" />
                    </Button>
                  </div>
                </CardContent>
              </Card>
            )
          })
        )}
      </div>
    </div>
  )
})

export default EssayList
```

### 7.2 Create `components/essays/EssayEditor.tsx`

```tsx
'use client'

import React, { useState, useCallback, useRef, useEffect, useMemo } from 'react'
import { Save, Clock, History, Settings, ChevronDown } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Input } from '@/components/ui/input'
import { Badge } from '@/components/ui/badge'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import { cn } from '@/lib/utils'
import { countWords } from '@/lib/diff'
import type { EssayDraftWithVersions, EssayVersion } from '@/lib/schemas'

// ============ TYPES ============

interface EssayEditorProps {
  essay: EssayDraftWithVersions
  latestContent: string
  onSaveVersion: (content: string, notes?: string) => void
  onUpdateDraft: (updates: Record<string, any>) => void
  onShowHistory: () => void
  isSaving: boolean
}

// ============ COMPONENT ============

export default function EssayEditor({
  essay,
  latestContent,
  onSaveVersion,
  onUpdateDraft,
  onShowHistory,
  isSaving