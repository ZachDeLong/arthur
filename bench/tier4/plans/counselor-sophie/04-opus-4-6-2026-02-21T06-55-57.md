

# Implementation Plan: Daily Deadline Reminder Cron Job

## Overview

Add a Vercel cron job that runs daily at 8:00 AM UTC, checks for upcoming college application deadlines within the next 7 days, sends in-app notifications to students who have saved those colleges, and tracks reminder history to prevent duplicates.

---

## 1. Database: Create New Tables

### 1a. Create `deadline_reminders` table (reminder history)

```sql
-- supabase/migrations/20250101000001_create_deadline_reminders.sql

-- Tracks which reminders have been sent to avoid duplicates
CREATE TABLE deadline_reminders (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  student_id UUID NOT NULL REFERENCES students(id) ON DELETE CASCADE,
  saved_college_id UUID NOT NULL REFERENCES saved_colleges(id) ON DELETE CASCADE,
  college_name TEXT NOT NULL,
  deadline_date DATE NOT NULL,
  deadline_type TEXT NOT NULL, -- 'early_decision', 'early_action', 'regular', 'rolling', etc.
  days_until_deadline INTEGER NOT NULL,
  sent_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- Prevent duplicate reminders for same student + college + deadline + day window
  UNIQUE(student_id, saved_college_id, deadline_type, days_until_deadline)
);

-- RLS: service-role only (cron job writes, students read their own)
ALTER TABLE deadline_reminders ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Students can read own reminders"
  ON deadline_reminders FOR SELECT
  USING ((SELECT auth.uid()) IN (
    SELECT profile_id FROM students WHERE id = student_id
  ));

CREATE POLICY "Service role can manage all reminders"
  ON deadline_reminders FOR ALL
  USING ((SELECT auth.role()) = 'service_role');

-- Index for efficient querying
CREATE INDEX idx_deadline_reminders_student ON deadline_reminders(student_id, sent_at DESC);
CREATE INDEX idx_deadline_reminders_lookup ON deadline_reminders(student_id, saved_college_id, deadline_type, days_until_deadline);
```

### 1b. Create `notifications` table (in-app notifications)

```sql
-- supabase/migrations/20250101000002_create_notifications.sql

CREATE TABLE notifications (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  student_id UUID NOT NULL REFERENCES students(id) ON DELETE CASCADE,
  type TEXT NOT NULL DEFAULT 'deadline_reminder', -- extensible for future notification types
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  metadata JSONB DEFAULT '{}', -- flexible payload (college_id, deadline_type, etc.)
  read BOOLEAN DEFAULT FALSE,
  read_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Students can read own notifications"
  ON notifications FOR SELECT
  USING ((SELECT auth.uid()) IN (
    SELECT profile_id FROM students WHERE id = student_id
  ));

CREATE POLICY "Students can update own notifications"
  ON notifications FOR UPDATE
  USING ((SELECT auth.uid()) IN (
    SELECT profile_id FROM students WHERE id = student_id
  ))
  WITH CHECK ((SELECT auth.uid()) IN (
    SELECT profile_id FROM students WHERE id = student_id
  ));

CREATE POLICY "Service role can manage all notifications"
  ON notifications FOR ALL
  USING ((SELECT auth.role()) = 'service_role');

CREATE INDEX idx_notifications_student ON notifications(student_id, read, created_at DESC);
CREATE INDEX idx_notifications_unread ON notifications(student_id, created_at DESC) WHERE read = FALSE;
```

---

## 2. Vercel Cron Configuration

### File: `vercel.json`

Create or modify the root `vercel.json`:

```json
{
  "crons": [
    {
      "path": "/api/cron/deadline-reminders",
      "schedule": "0 8 * * *"
    }
  ]
}
```

---

## 3. Zod Schemas

### File: `lib/schemas.ts` (append to existing file)

```typescript
// ============ DEADLINE REMINDERS ============

export const DeadlineReminderSchema = z.object({
  id: z.string().uuid(),
  student_id: z.string().uuid(),
  saved_college_id: z.string().uuid(),
  college_name: z.string(),
  deadline_date: z.string(),
  deadline_type: z.string(),
  days_until_deadline: z.number(),
  sent_at: z.string(),
  created_at: z.string(),
})

export type DeadlineReminder = z.infer<typeof DeadlineReminderSchema>

export const NotificationSchema = z.object({
  id: z.string().uuid(),
  student_id: z.string().uuid(),
  type: z.string(),
  title: z.string(),
  message: z.string(),
  metadata: z.record(z.unknown()).optional(),
  read: z.boolean(),
  read_at: z.string().nullable().optional(),
  created_at: z.string(),
})

export type Notification = z.infer<typeof NotificationSchema>

export const MarkNotificationReadRequestSchema = z.object({
  notification_id: z.string().uuid(),
})

export const MarkAllNotificationsReadRequestSchema = z.object({
  student_id: z.string().uuid(),
})
```

---

## 4. Cron API Route

### File: `app/api/cron/deadline-reminders/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/server'

// Vercel cron jobs send this header for authentication
const CRON_SECRET = process.env.CRON_SECRET

interface UpcomingDeadline {
  saved_college_id: string
  student_id: string
  college_name: string
  deadline_date: string
  deadline_type: string
  days_until: number
}

export async function GET(request: NextRequest) {
  // Verify the request is from Vercel Cron
  const authHeader = request.headers.get('authorization')
  if (CRON_SECRET && authHeader !== `Bearer ${CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const supabase = createServiceRoleClient()
  const now = new Date()
  const today = now.toISOString().split('T')[0]
  const sevenDaysOut = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]

  console.log(`[deadline-reminders] Running for ${today} through ${sevenDaysOut}`)

  try {
    // Step 1: Fetch all saved colleges with deadlines in the next 7 days
    // The saved_colleges table has deadline columns: early_decision_deadline, early_action_deadline,
    // regular_deadline, and possibly a generic deadline column
    const { data: savedColleges, error: fetchError } = await supabase
      .from('saved_colleges')
      .select('id, student_id, college_name, early_decision_deadline, early_action_deadline, regular_deadline')

    if (fetchError) {
      console.error('[deadline-reminders] Error fetching saved colleges:', fetchError)
      return NextResponse.json({ error: 'Failed to fetch colleges' }, { status: 500 })
    }

    if (!savedColleges || savedColleges.length === 0) {
      console.log('[deadline-reminders] No saved colleges found')
      return NextResponse.json({ message: 'No saved colleges', reminders_sent: 0 })
    }

    // Step 2: Build list of upcoming deadlines
    const upcomingDeadlines: UpcomingDeadline[] = []

    const deadlineFields = [
      { column: 'early_decision_deadline', type: 'Early Decision' },
      { column: 'early_action_deadline', type: 'Early Action' },
      { column: 'regular_deadline', type: 'Regular Decision' },
    ] as const

    for (const college of savedColleges) {
      for (const field of deadlineFields) {
        const deadlineValue = college[field.column]
        if (!deadlineValue) continue

        const deadlineDate = new Date(deadlineValue)
        const deadlineStr = deadlineDate.toISOString().split('T')[0]

        // Check if deadline is between today and 7 days out (inclusive)
        if (deadlineStr >= today && deadlineStr <= sevenDaysOut) {
          const diffMs = deadlineDate.getTime() - now.getTime()
          const daysUntil = Math.ceil(diffMs / (1000 * 60 * 60 * 24))

          upcomingDeadlines.push({
            saved_college_id: college.id,
            student_id: college.student_id,
            college_name: college.college_name,
            deadline_date: deadlineStr,
            deadline_type: field.type,
            days_until: daysUntil,
          })
        }
      }
    }

    console.log(`[deadline-reminders] Found ${upcomingDeadlines.length} upcoming deadlines`)

    if (upcomingDeadlines.length === 0) {
      return NextResponse.json({ message: 'No upcoming deadlines', reminders_sent: 0 })
    }

    // Step 3: Filter out already-sent reminders
    // We check for existing reminders with the same student + college + type + days_until
    const reminderChecks = upcomingDeadlines.map((d) => ({
      student_id: d.student_id,
      saved_college_id: d.saved_college_id,
      deadline_type: d.deadline_type,
      days_until_deadline: d.days_until,
    }))

    // Fetch existing reminders for these combinations
    const { data: existingReminders, error: reminderError } = await supabase
      .from('deadline_reminders')
      .select('student_id, saved_college_id, deadline_type, days_until_deadline')
      .in(
        'student_id',
        [...new Set(reminderChecks.map((r) => r.student_id))]
      )

    if (reminderError) {
      console.error('[deadline-reminders] Error fetching existing reminders:', reminderError)
      return NextResponse.json({ error: 'Failed to check existing reminders' }, { status: 500 })
    }

    // Build a Set of already-sent reminder keys for fast lookup
    const sentKeys = new Set(
      (existingReminders || []).map(
        (r) => `${r.student_id}|${r.saved_college_id}|${r.deadline_type}|${r.days_until_deadline}`
      )
    )

    const newDeadlines = upcomingDeadlines.filter(
      (d) => !sentKeys.has(`${d.student_id}|${d.saved_college_id}|${d.deadline_type}|${d.days_until}`)
    )

    console.log(`[deadline-reminders] ${newDeadlines.length} new reminders to send (${upcomingDeadlines.length - newDeadlines.length} already sent)`)

    if (newDeadlines.length === 0) {
      return NextResponse.json({ message: 'All reminders already sent', reminders_sent: 0 })
    }

    // Step 4: Insert reminder records
    const reminderRecords = newDeadlines.map((d) => ({
      student_id: d.student_id,
      saved_college_id: d.saved_college_id,
      college_name: d.college_name,
      deadline_date: d.deadline_date,
      deadline_type: d.deadline_type,
      days_until_deadline: d.days_until,
    }))

    const { error: insertReminderError } = await supabase
      .from('deadline_reminders')
      .upsert(reminderRecords, {
        onConflict: 'student_id,saved_college_id,deadline_type,days_until_deadline',
        ignoreDuplicates: true,
      })

    if (insertReminderError) {
      console.error('[deadline-reminders] Error inserting reminders:', insertReminderError)
      return NextResponse.json({ error: 'Failed to insert reminders' }, { status: 500 })
    }

    // Step 5: Create in-app notifications
    const notificationRecords = newDeadlines.map((d) => {
      const urgencyPrefix = d.days_until <= 1 ? 'ðŸš¨' : d.days_until <= 3 ? 'âš ï¸' : 'ðŸ“…'
      const daysText = d.days_until === 0 ? 'today' : d.days_until === 1 ? 'tomorrow' : `in ${d.days_until} days`

      return {
        student_id: d.student_id,
        type: 'deadline_reminder',
        title: `${urgencyPrefix} ${d.deadline_type} Deadline ${daysText}`,
        message: `${d.college_name}'s ${d.deadline_type} deadline is ${daysText} (${d.deadline_date}). Make sure your application is submitted!`,
        metadata: {
          saved_college_id: d.saved_college_id,
          college_name: d.college_name,
          deadline_type: d.deadline_type,
          deadline_date: d.deadline_date,
          days_until: d.days_until,
        },
      }
    })

    const { error: insertNotifError } = await supabase
      .from('notifications')
      .insert(notificationRecords)

    if (insertNotifError) {
      console.error('[deadline-reminders] Error inserting notifications:', insertNotifError)
      return NextResponse.json({ error: 'Failed to create notifications' }, { status: 500 })
    }

    console.log(`[deadline-reminders] Successfully sent ${newDeadlines.length} reminders`)

    return NextResponse.json({
      message: 'Reminders sent successfully',
      reminders_sent: newDeadlines.length,
      deadlines_checked: upcomingDeadlines.length,
      duplicates_skipped: upcomingDeadlines.length - newDeadlines.length,
    })
  } catch (error) {
    console.error('[deadline-reminders] Unexpected error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```

---

## 5. Notifications API Routes

### File: `app/api/notifications/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

// GET /api/notifications â€” Fetch notifications for the current user's student
export async function GET(request: NextRequest) {
  const supabase = await createClient()

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser()

  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // Look up the student for this user
  const { data: student, error: studentError } = await supabase
    .from('students')
    .select('id')
    .eq('profile_id', user.id)
    .single()

  if (studentError || !student) {
    return NextResponse.json({ error: 'Student not found' }, { status: 404 })
  }

  const { searchParams } = new URL(request.url)
  const unreadOnly = searchParams.get('unread') === 'true'
  const limit = parseInt(searchParams.get('limit') || '50', 10)

  let query = supabase
    .from('notifications')
    .select('*')
    .eq('student_id', student.id)
    .order('created_at', { ascending: false })
    .limit(limit)

  if (unreadOnly) {
    query = query.eq('read', false)
  }

  const { data: notifications, error } = await query

  if (error) {
    console.error('[notifications] Error fetching:', error)
    return NextResponse.json({ error: 'Failed to fetch notifications' }, { status: 500 })
  }

  // Also get unread count
  const { count } = await supabase
    .from('notifications')
    .select('*', { count: 'exact', head: true })
    .eq('student_id', student.id)
    .eq('read', false)

  return NextResponse.json({
    notifications: notifications || [],
    unread_count: count || 0,
  })
}
```

### File: `app/api/notifications/read/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { parseRequestBody, MarkNotificationReadRequestSchema, MarkAllNotificationsReadRequestSchema } from '@/lib/schemas'

// PATCH /api/notifications/read â€” Mark a single notification as read
export async function PATCH(request: NextRequest) {
  const supabase = await createClient()

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser()

  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const body = await request.json()
  const parsed = parseRequestBody(MarkNotificationReadRequestSchema, body)
  if (!parsed.success) return parsed.response

  const { notification_id } = parsed.data

  const { error } = await supabase
    .from('notifications')
    .update({ read: true, read_at: new Date().toISOString() })
    .eq('id', notification_id)

  if (error) {
    console.error('[notifications] Error marking as read:', error)
    return NextResponse.json({ error: 'Failed to mark notification as read' }, { status: 500 })
  }

  return NextResponse.json({ success: true })
}

// POST /api/notifications/read â€” Mark all notifications as read for a student
export async function POST(request: NextRequest) {
  const supabase = await createClient()

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser()

  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const body = await request.json()
  const parsed = parseRequestBody(MarkAllNotificationsReadRequestSchema, body)
  if (!parsed.success) return parsed.response

  const { student_id } = parsed.data

  const { error } = await supabase
    .from('notifications')
    .update({ read: true, read_at: new Date().toISOString() })
    .eq('student_id', student_id)
    .eq('read', false)

  if (error) {
    console.error('[notifications] Error marking all as read:', error)
    return NextResponse.json({ error: 'Failed to mark notifications as read' }, { status: 500 })
  }

  return NextResponse.json({ success: true })
}
```

---

## 6. TanStack Query Hooks

### File: `hooks/useNotifications.ts`

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import type { Notification } from '@/lib/schemas'

interface NotificationsResponse {
  notifications: Notification[]
  unread_count: number
}

// ============ QUERY KEYS ============

export const notificationKeys = {
  all: ['notifications'] as const,
  list: (unread?: boolean) => [...notificationKeys.all, { unread }] as const,
  unreadCount: () => [...notificationKeys.all, 'unread-count'] as const,
}

// ============ QUERIES ============

export function useNotifications(options?: { unreadOnly?: boolean; limit?: number }) {
  const { unreadOnly = false, limit = 50 } = options || {}

  return useQuery<NotificationsResponse>({
    queryKey: notificationKeys.list(unreadOnly),
    queryFn: async () => {
      const params = new URLSearchParams()
      if (unreadOnly) params.set('unread', 'true')
      params.set('limit', String(limit))

      const res = await fetch(`/api/notifications?${params.toString()}`)
      if (!res.ok) throw new Error('Failed to fetch notifications')
      return res.json()
    },
    // Poll every 5 minutes for new notifications
    refetchInterval: 5 * 60 * 1000,
  })
}

export function useUnreadCount() {
  return useQuery<number>({
    queryKey: notificationKeys.unreadCount(),
    queryFn: async () => {
      const res = await fetch('/api/notifications?unread=true&limit=0')
      if (!res.ok) throw new Error('Failed to fetch unread count')
      const data = await res.json()
      return data.unread_count
    },
    refetchInterval: 2 * 60 * 1000, // Poll every 2 minutes for badge updates
  })
}

// ============ MUTATIONS ============

export function useMarkNotificationRead() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (notificationId: string) => {
      const res = await fetch('/api/notifications/read', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ notification_id: notificationId }),
      })
      if (!res.ok) throw new Error('Failed to mark notification as read')
      return res.json()
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: notificationKeys.all })
    },
  })
}

export function useMarkAllNotificationsRead() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (studentId: string) => {
      const res = await fetch('/api/notifications/read', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ student_id: studentId }),
      })
      if (!res.ok) throw new Error('Failed to mark all notifications as read')
      return res.json()
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: notificationKeys.all })
    },
  })
}
```

---

## 7. Notification Bell Component

### File: `components/layout/NotificationBell.tsx`

```typescript
'use client'

import React, { useState, useRef, useEffect } from 'react'
import { Bell } from 'lucide-react'
import { cn } from '@/lib/utils'
import { useNotifications, useUnreadCount, useMarkNotificationRead, useMarkAllNotificationsRead } from '@/hooks/useNotifications'
import { useStudentData } from '@/hooks/useStudentData'
import type { Notification } from '@/lib/schemas'

function NotificationItem({
  notification,
  onMarkRead,
}: {
  notification: Notification
  onMarkRead: (id: string) => void
}) {
  const timeAgo = getTimeAgo(notification.created_at)

  return (
    <button
      onClick={() => !notification.read && onMarkRead(notification.id)}
      className={cn(
        'w-full text-left px-4 py-3 border-b border-gray-100 hover:bg-gray-50 transition-colors',
        !notification.read && 'bg-blue-50/50'
      )}
    >
      <div className="flex items-start justify-between gap-2">
        <div className="flex-1 min-w-0">
          <p className={cn('text-sm', !notification.read ? 'font-semibold text-gray-900' : 'text-gray-700')}>
            {notification.title}
          </p>
          <p className="text-xs text-gray-500 mt-0.5 line-clamp-2">{notification.message}</p>
        </div>
        <div className="flex items-center gap-1.5 shrink-0">
          <span className="text-xs text-gray-400">{timeAgo}</span>
          {!notification.read && <span className="w-2 h-2 rounded-full bg-blue-500" />}
        </div>
      </div>
    </button>
  )
}

const MemoizedNotificationItem = React.memo(NotificationItem)

export function NotificationBell() {
  const [isOpen, setIsOpen] = useState(false)
  const dropdownRef = useRef<HTMLDivElement>(null)

  const { data: studentData } = useStudentData()
  const studentId = studentData?.id

  const { data: unreadCount = 0 } = useUnreadCount()
  const { data: notificationsData } = useNotifications({ limit: 20 })
  const markRead = useMarkNotificationRead()
  const markAllRead = useMarkAllNotificationsRead()

  const notifications = notificationsData?.notifications || []

  // Close dropdown on outside click
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  const handleMarkRead = (notificationId: string) => {
    markRead.mutate(notificationId)
  }

  const handleMarkAllRead = () => {
    if (studentId) {
      markAllRead.mutate(studentId)
    }
  }

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 rounded-lg hover:bg-gray-100 transition-colors"
        aria-label={`Notifications${unreadCount > 0 ? ` (${unreadCount} unread)` : ''}`}
      >
        <Bell className="h-5 w-5 text-gray-600" />
        {unreadCount > 0 && (
          <span className="absolute -top-0.5 -right-0.5 flex items-center justify-center min-w-[18px] h-[18px] px-1 text-[10px] font-bold text-white bg-red-500 rounded-full">
            {unreadCount > 99 ? '99+' : unreadCount}
          </span>
        )}
      </button>

      {isOpen && (
        <div className="absolute right-0 top-full mt-2 w-96 bg-white rounded-xl shadow-lg border border-gray-200 z-50 overflow-hidden">
          {/* Header */}
          <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200">
            <h3 className="text-sm font-semibold text-gray-900">Notifications</h3>
            {unreadCount > 0 && (
              <button
                onClick={handleMarkAllRead}
                className="text-xs text-blue-600 hover:text-blue-700 font-medium"
              >
                Mark all as read
              </button>
            )}
          </div>

          {/* Notification list */}
          <div className="max-h-96 overflow-y-auto">
            {notifications.length === 0 ? (
              <div className="px-4 py-8 text-center text-sm text-gray-500">
                No notifications yet
              </div>
            ) : (
              notifications.map((notification) => (
                <MemoizedNotificationItem
                  key={notification.id}
                  notification={notification}
                  onMarkRead={handleMarkRead}
                />
              ))
            )}
          </div>
        </div>
      )}
    </div>
  )
}

// ============ HELPERS ============

function getTimeAgo(dateStr: string): string {
  const now = new Date()
  const date = new Date(dateStr)
  const diffMs = now.getTime() - date.getTime()
  const diffMinutes = Math.floor(diffMs / (1000 * 60))

  if (diffMinutes < 1) return 'now'
  if (diffMinutes < 60) return `${diffMinutes}m`
  const diffHours = Math.floor(diffMinutes / 60)
  if (diffHours < 24) return `${diffHours}h`
  const diffDays = Math.floor(diffHours / 24)
  if (diffDays < 7) return `${diffDays}d`
  return `${Math.floor(diffDays / 7)}w`
}
```

---

## 8. Integrate NotificationBell into AppShell

### File: `components/layout/AppShell.tsx` (modify existing)

Add the notification bell to the header/navigation area:

```typescript
// Add import at top of file
import { NotificationBell } from '@/components/layout/NotificationBell'

// In the header/nav bar JSX, add before the user menu/avatar:
// Find the existing header section and add NotificationBell

// Example â€” locate the header bar (likely contains logo + nav + user avatar)
// and insert the bell between nav items and user controls:

// Before (approximate existing structure):
// <div className="flex items-center gap-4">
//   {/* user avatar / menu */}
// </div>

// After:
// <div className="flex items-center gap-4">
//   <NotificationBell />
//   {/* user avatar / menu */}
// </div>
```

The precise location depends on the existing `AppShell` structure, but the `NotificationBell` should be placed in the top navigation bar, typically to the left of any user avatar or settings button.

---

## 9. Environment Variable

### File: `.env.local` (append)

```bash
# Vercel Cron authentication secret
CRON_SECRET=                  # Generate with: openssl rand -hex 32
```

Vercel automatically sends `Authorization: Bearer <CRON_SECRET>` when invoking cron endpoints if `CRON_SECRET` is set in the project environment variables.

---

## 10. Zustand Store Update (optional notification count)

### File: `store/index.ts` (append to existing)

```typescript
// ============ NOTIFICATION STATE ============

// Add to the store interface:
// notificationPanelOpen: boolean
// setNotificationPanelOpen: (open: boolean) => void

// Add to the store creation:
// notificationPanelOpen: false,
// setNotificationPanelOpen: (open) => set({ notificationPanelOpen: open }),

// Add granular selector:
// export const useNotificationPanelOpen = () => useStore((s) => s.notificationPanelOpen)
// export const useSetNotificationPanelOpen = () => useStore((s) => s.setNotificationPanelOpen)
```

This is optional â€” the `NotificationBell` uses local `useState` which is fine for a simple dropdown. Only add to Zustand if other components need to control the notification panel.

---

## 11. Dashboard Integration (Upcoming Deadlines Widget)

### File: `components/dashboard/UpcomingDeadlines.tsx`

```typescript
'use client'

import React from 'react'
import { Calendar, AlertTriangle } from 'lucide-react'
import { cn } from '@/lib/utils'
import { useNotifications } from '@/hooks/useNotifications