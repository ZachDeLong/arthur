

# Implementation Plan: AI-Powered College Recommendation Explanations

## Overview

Add persistent, AI-generated explanations for why each college is a good fit for a student. When viewing recommended colleges, students can click to generate/view a personalized explanation. Explanations are cached in Supabase and streamed via the Vercel AI SDK.

---

## 1. Database: Create `college_explanations` Table

Run this migration in Supabase SQL Editor:

```sql
-- Create the college_explanations table
CREATE TABLE public.college_explanations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  student_id UUID NOT NULL REFERENCES public.students(id) ON DELETE CASCADE,
  college_id UUID NOT NULL REFERENCES public.college_tiers(id) ON DELETE CASCADE,
  college_name TEXT NOT NULL,
  explanation TEXT NOT NULL,
  model_used TEXT NOT NULL DEFAULT 'claude-haiku-4-5-20251001',
  profile_hash TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  UNIQUE(student_id, college_id)
);

-- Index for fast lookups
CREATE INDEX idx_college_explanations_student ON public.college_explanations(student_id);
CREATE INDEX idx_college_explanations_student_college ON public.college_explanations(student_id, college_id);

-- Enable RLS
ALTER TABLE public.college_explanations ENABLE ROW LEVEL SECURITY;

-- RLS policies using existing has_student_access function
CREATE POLICY "Users can view explanations for their students"
  ON public.college_explanations
  FOR SELECT
  USING (has_student_access(student_id));

CREATE POLICY "Users can insert explanations for their students"
  ON public.college_explanations
  FOR INSERT
  WITH CHECK (has_student_access(student_id));

CREATE POLICY "Users can update explanations for their students"
  ON public.college_explanations
  FOR UPDATE
  USING (has_student_access(student_id));

CREATE POLICY "Users can delete explanations for their students"
  ON public.college_explanations
  FOR DELETE
  USING (has_student_access(student_id));

-- Service role bypass for AI route caching
CREATE POLICY "Service role full access"
  ON public.college_explanations
  FOR ALL
  USING (auth.role() = 'service_role');

-- Auto-update updated_at
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.college_explanations
  FOR EACH ROW
  EXECUTE FUNCTION moddatetime(updated_at);
```

**`profile_hash`** is a hash of the student's key profile fields at generation time. If the profile changes significantly, we can detect staleness and regenerate.

---

## 2. Zod Schemas — `lib/schemas.ts`

Add request/response schemas to the existing file:

```typescript
// lib/schemas.ts — ADD these schemas

// ============ COLLEGE EXPLANATION SCHEMAS ============

export const CollegeExplanationRequestSchema = z.object({
  studentId: z.string().uuid(),
  collegeId: z.string().uuid(),
  collegeName: z.string().min(1),
})

export type CollegeExplanationRequest = z.infer<typeof CollegeExplanationRequestSchema>

export const CollegeExplanationResponseSchema = z.object({
  explanation: z.string(),
  cached: z.boolean(),
  profileHash: z.string(),
})

export type CollegeExplanationResponse = z.infer<typeof CollegeExplanationResponseSchema>

export const CollegeExplanationBatchRequestSchema = z.object({
  studentId: z.string().uuid(),
  collegeIds: z.array(z.string().uuid()).min(1).max(20),
})

export type CollegeExplanationBatchRequest = z.infer<typeof CollegeExplanationBatchRequestSchema>

export const CollegeExplanationSchema = z.object({
  id: z.string().uuid(),
  student_id: z.string().uuid(),
  college_id: z.string().uuid(),
  college_name: z.string(),
  explanation: z.string(),
  model_used: z.string(),
  profile_hash: z.string(),
  created_at: z.string(),
  updated_at: z.string(),
})

export type CollegeExplanation = z.infer<typeof CollegeExplanationSchema>
```

---

## 3. Profile Hash Utility — `lib/profile-hash.ts`

Create a utility to compute a deterministic hash of student profile fields so we know when explanations are stale:

```typescript
// lib/profile-hash.ts

import { createHash } from 'crypto'

export interface ProfileHashInput {
  gpa?: number | null
  sat_score?: number | null
  act_score?: number | null
  ap_courses?: string[] | null
  activities?: Array<{ name: string; category?: string }> | null
  competitions?: Array<{ competition_name: string }> | null
  intended_major?: string | null
  state?: string | null
}

export function computeProfileHash(profile: ProfileHashInput): string {
  const normalized = {
    gpa: profile.gpa ?? null,
    sat: profile.sat_score ?? null,
    act: profile.act_score ?? null,
    aps: (profile.ap_courses ?? []).sort(),
    activities: (profile.activities ?? [])
      .map((a) => a.name)
      .sort(),
    competitions: (profile.competitions ?? [])
      .map((c) => c.competition_name)
      .sort(),
    major: profile.intended_major ?? null,
    state: profile.state ?? null,
  }

  return createHash('sha256').update(JSON.stringify(normalized)).digest('hex').slice(0, 16)
}
```

---

## 4. Database Helper Functions — `lib/db.ts`

Add college explanation CRUD operations to the existing `lib/db.ts`:

```typescript
// lib/db.ts — ADD these functions

import type { CollegeExplanation } from './schemas'

// ============ COLLEGE EXPLANATIONS ============

export async function getCollegeExplanation(
  client: SupabaseClient,
  studentId: string,
  collegeId: string,
): Promise<CollegeExplanation | null> {
  const { data, error } = await client
    .from('college_explanations')
    .select('*')
    .eq('student_id', studentId)
    .eq('college_id', collegeId)
    .single()

  if (error && error.code !== 'PGRST116') {
    console.error('Error fetching college explanation:', error)
    throw error
  }

  return data ?? null
}

export async function getCollegeExplanationsByStudent(
  client: SupabaseClient,
  studentId: string,
): Promise<CollegeExplanation[]> {
  const { data, error } = await client
    .from('college_explanations')
    .select('*')
    .eq('student_id', studentId)
    .order('created_at', { ascending: false })

  if (error) {
    console.error('Error fetching college explanations:', error)
    throw error
  }

  return data ?? []
}

export async function upsertCollegeExplanation(
  client: SupabaseClient,
  params: {
    student_id: string
    college_id: string
    college_name: string
    explanation: string
    model_used: string
    profile_hash: string
  },
): Promise<CollegeExplanation> {
  const { data, error } = await client
    .from('college_explanations')
    .upsert(
      {
        student_id: params.student_id,
        college_id: params.college_id,
        college_name: params.college_name,
        explanation: params.explanation,
        model_used: params.model_used,
        profile_hash: params.profile_hash,
        updated_at: new Date().toISOString(),
      },
      { onConflict: 'student_id,college_id' },
    )
    .select()
    .single()

  if (error) {
    console.error('Error upserting college explanation:', error)
    throw error
  }

  return data
}

export async function deleteCollegeExplanation(
  client: SupabaseClient,
  studentId: string,
  collegeId: string,
): Promise<void> {
  const { error } = await client
    .from('college_explanations')
    .delete()
    .eq('student_id', studentId)
    .eq('college_id', collegeId)

  if (error) {
    console.error('Error deleting college explanation:', error)
    throw error
  }
}
```

---

## 5. API Route — `app/api/college-explanation/route.ts`

### GET: Fetch cached explanation
### POST: Generate new explanation (streaming)

```typescript
// app/api/college-explanation/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { streamText } from 'ai'
import { createAnthropic } from '@ai-sdk/anthropic'
import { createServiceRoleClient } from '@/lib/supabase/server'
import { parseRequestBody, CollegeExplanationRequestSchema } from '@/lib/schemas'
import { computeProfileHash } from '@/lib/profile-hash'
import {
  getCollegeExplanation,
  upsertCollegeExplanation,
} from '@/lib/db'

const anthropic = createAnthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
})

// GET: Check for cached explanation
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const studentId = searchParams.get('studentId')
  const collegeId = searchParams.get('collegeId')

  if (!studentId || !collegeId) {
    return NextResponse.json({ error: 'Missing studentId or collegeId' }, { status: 400 })
  }

  const supabase = createServiceRoleClient()

  try {
    const explanation = await getCollegeExplanation(supabase, studentId, collegeId)

    if (!explanation) {
      return NextResponse.json({ cached: false, explanation: null }, { status: 200 })
    }

    // Check staleness: fetch current profile hash
    const profileHash = await fetchCurrentProfileHash(supabase, studentId)

    return NextResponse.json({
      cached: true,
      stale: explanation.profile_hash !== profileHash,
      explanation: explanation.explanation,
      profileHash: explanation.profile_hash,
      updatedAt: explanation.updated_at,
    })
  } catch (error) {
    console.error('Error fetching explanation:', error)
    return NextResponse.json({ error: 'Failed to fetch explanation' }, { status: 500 })
  }
}

// POST: Generate explanation with streaming
export async function POST(request: NextRequest) {
  const body = await request.json()
  const parsed = parseRequestBody(CollegeExplanationRequestSchema, body)
  if (!parsed.success) return parsed.response

  const { studentId, collegeId, collegeName } = parsed.data
  const supabase = createServiceRoleClient()

  try {
    // 1. Fetch student profile data
    const studentProfile = await fetchStudentProfile(supabase, studentId)
    if (!studentProfile) {
      return NextResponse.json({ error: 'Student not found' }, { status: 404 })
    }

    // 2. Fetch college data
    const collegeData = await fetchCollegeData(supabase, collegeId)

    // 3. Compute current profile hash
    const profileHash = computeProfileHash(studentProfile)

    // 4. Check if we have a fresh cached explanation
    const existing = await getCollegeExplanation(supabase, studentId, collegeId)
    if (existing && existing.profile_hash === profileHash) {
      return NextResponse.json({
        cached: true,
        explanation: existing.explanation,
        profileHash: existing.profile_hash,
      })
    }

    // 5. Build the prompt
    const systemPrompt = buildSystemPrompt()
    const userPrompt = buildUserPrompt(studentProfile, collegeName, collegeData)

    // 6. Stream the response
    const result = streamText({
      model: anthropic('claude-haiku-4-5-20251001'),
      system: systemPrompt,
      prompt: userPrompt,
      maxTokens: 800,
      temperature: 0.7,
      async onFinish({ text }) {
        // 7. Cache the completed explanation
        try {
          await upsertCollegeExplanation(supabase, {
            student_id: studentId,
            college_id: collegeId,
            college_name: collegeName,
            explanation: text,
            model_used: 'claude-haiku-4-5-20251001',
            profile_hash: profileHash,
          })
        } catch (cacheError) {
          console.error('Failed to cache explanation:', cacheError)
          // Don't fail the response if caching fails
        }
      },
    })

    return result.toTextStreamResponse()
  } catch (error) {
    console.error('Error generating explanation:', error)
    return NextResponse.json({ error: 'Failed to generate explanation' }, { status: 500 })
  }
}

// ============ HELPER FUNCTIONS ============

async function fetchStudentProfile(supabase: ReturnType<typeof createServiceRoleClient>, studentId: string) {
  // Fetch student basic info
  const { data: student } = await supabase
    .from('students')
    .select(`
      id,
      first_name,
      last_name,
      grade,
      gpa,
      sat_score,
      act_score,
      intended_major,
      state,
      ap_courses,
      resume_notes
    `)
    .eq('id', studentId)
    .single()

  if (!student) return null

  // Fetch activities
  const { data: activities } = await supabase
    .from('activities')
    .select('name, category, description, hours_per_week, leadership_role')
    .eq('student_id', studentId)
    .order('hours_per_week', { ascending: false })
    .limit(10)

  // Fetch competitions/awards
  const { data: competitions } = await supabase
    .from('saved_competitions')
    .select('competition_name, level, result')
    .eq('student_id', studentId)
    .limit(10)

  // Fetch saved colleges with tiers for context
  const { data: savedColleges } = await supabase
    .from('saved_colleges')
    .select(`
      tier,
      college_tiers (
        name,
        acceptance_rate,
        avg_sat,
        avg_act
      )
    `)
    .eq('student_id', studentId)
    .limit(20)

  return {
    ...student,
    activities: activities ?? [],
    competitions: competitions ?? [],
    savedColleges: savedColleges ?? [],
  }
}

async function fetchCollegeData(supabase: ReturnType<typeof createServiceRoleClient>, collegeId: string) {
  const { data } = await supabase
    .from('college_tiers')
    .select(`
      id,
      name,
      acceptance_rate,
      avg_sat,
      avg_act,
      location,
      institution_type,
      size,
      notable_programs,
      ranking
    `)
    .eq('id', collegeId)
    .single()

  return data
}

async function fetchCurrentProfileHash(
  supabase: ReturnType<typeof createServiceRoleClient>,
  studentId: string,
): Promise<string> {
  const profile = await fetchStudentProfile(supabase, studentId)
  if (!profile) return ''
  return computeProfileHash(profile)
}

function buildSystemPrompt(): string {
  return `You are CounselorSophie, an expert college admissions counselor. 
You provide personalized, encouraging explanations for why specific colleges are good fits for students.

Your explanations should:
- Be specific to the student's profile (GPA, test scores, activities, interests)
- Reference concrete aspects of the college (programs, culture, opportunities)
- Be warm but honest — note where it's a stretch vs a strong match
- Be 3-5 paragraphs long
- Use second person ("you" / "your")
- Avoid generic platitudes — be specific and actionable
- If relevant, mention how the student's extracurriculars align with college offerings
- End with 1-2 specific suggestions for strengthening their application to this school`
}

function buildUserPrompt(
  profile: Awaited<ReturnType<typeof fetchStudentProfile>>,
  collegeName: string,
  collegeData: Awaited<ReturnType<typeof fetchCollegeData>>,
): string {
  const activitiesStr = profile!.activities
    .map((a) => `- ${a.name}${a.category ? ` (${a.category})` : ''}${a.leadership_role ? ' [Leadership]' : ''}${a.hours_per_week ? ` - ${a.hours_per_week}hrs/wk` : ''}`)
    .join('\n')

  const competitionsStr = profile!.competitions
    .map((c) => `- ${c.competition_name}${c.level ? ` (${c.level})` : ''}${c.result ? ` — ${c.result}` : ''}`)
    .join('\n')

  const collegeInfo = collegeData
    ? `
College Details:
- Acceptance Rate: ${collegeData.acceptance_rate ? `${(collegeData.acceptance_rate * 100).toFixed(1)}%` : 'Unknown'}
- Average SAT: ${collegeData.avg_sat ?? 'Unknown'}
- Average ACT: ${collegeData.avg_act ?? 'Unknown'}
- Location: ${collegeData.location ?? 'Unknown'}
- Type: ${collegeData.institution_type ?? 'Unknown'}
- Size: ${collegeData.size ?? 'Unknown'}
- Notable Programs: ${collegeData.notable_programs ?? 'Unknown'}
- Ranking: ${collegeData.ranking ?? 'Unknown'}
`
    : ''

  return `Please explain why ${collegeName} could be a good fit for this student.

Student Profile:
- Grade: ${profile!.grade ?? 'Unknown'}
- GPA: ${profile!.gpa ?? 'Unknown'}
- SAT: ${profile!.sat_score ?? 'Not taken'}
- ACT: ${profile!.act_score ?? 'Not taken'}
- Intended Major: ${profile!.intended_major ?? 'Undecided'}
- State: ${profile!.state ?? 'Unknown'}
- AP Courses: ${profile!.ap_courses?.join(', ') || 'None listed'}

Activities:
${activitiesStr || 'None listed'}

Competitions/Awards:
${competitionsStr || 'None listed'}

${collegeInfo}

${profile!.resume_notes ? `Additional Notes: ${profile!.resume_notes}` : ''}

Provide a personalized explanation of why ${collegeName} is a good fit for this student, considering their academic profile, extracurricular activities, and interests.`
}
```

---

## 6. TanStack Query Hooks — `hooks/useCollegeExplanations.ts`

```typescript
// hooks/useCollegeExplanations.ts

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { createClient } from '@/lib/supabase/client'
import type { CollegeExplanation } from '@/lib/schemas'

// ============ QUERY KEYS ============

export const explanationKeys = {
  all: (studentId: string) => ['college-explanations', studentId] as const,
  single: (studentId: string, collegeId: string) =>
    ['college-explanations', studentId, collegeId] as const,
}

// ============ FETCH ALL EXPLANATIONS FOR A STUDENT ============

export function useCollegeExplanations(studentId: string | undefined) {
  return useQuery({
    queryKey: explanationKeys.all(studentId ?? ''),
    queryFn: async (): Promise<CollegeExplanation[]> => {
      const supabase = createClient()
      const { data, error } = await supabase
        .from('college_explanations')
        .select('*')
        .eq('student_id', studentId!)
        .order('updated_at', { ascending: false })

      if (error) throw error
      return data ?? []
    },
    enabled: !!studentId,
  })
}

// ============ FETCH SINGLE CACHED EXPLANATION ============

export function useCollegeExplanation(studentId: string | undefined, collegeId: string | undefined) {
  return useQuery({
    queryKey: explanationKeys.single(studentId ?? '', collegeId ?? ''),
    queryFn: async (): Promise<{ cached: boolean; explanation: string | null; stale?: boolean }> => {
      const res = await fetch(
        `/api/college-explanation?studentId=${studentId}&collegeId=${collegeId}`,
      )
      if (!res.ok) throw new Error('Failed to fetch explanation')
      return res.json()
    },
    enabled: !!studentId && !!collegeId,
    staleTime: 10 * 60 * 1000, // 10 minutes
  })
}

// ============ GENERATE EXPLANATION (STREAMING) ============

export function useGenerateExplanation(studentId: string | undefined) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      collegeId,
      collegeName,
      onChunk,
    }: {
      collegeId: string
      collegeName: string
      onChunk?: (text: string) => void
    }): Promise<string> => {
      const res = await fetch('/api/college-explanation', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          studentId,
          collegeId,
          collegeName,
        }),
      })

      if (!res.ok) {
        // Check if it's a cached JSON response
        const contentType = res.headers.get('content-type')
        if (contentType?.includes('application/json')) {
          const json = await res.json()
          if (json.cached) return json.explanation
          throw new Error(json.error || 'Failed to generate explanation')
        }
        throw new Error('Failed to generate explanation')
      }

      // Check if response is JSON (cached) or stream (new generation)
      const contentType = res.headers.get('content-type')
      if (contentType?.includes('application/json')) {
        const json = await res.json()
        return json.explanation
      }

      // Handle streaming response
      const reader = res.body?.getReader()
      if (!reader) throw new Error('No response body')

      const decoder = new TextDecoder()
      let fullText = ''

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        const chunk = decoder.decode(value, { stream: true })
        fullText += chunk
        onChunk?.(fullText)
      }

      return fullText
    },
    onSuccess: (_data, variables) => {
      // Invalidate both single and list queries
      queryClient.invalidateQueries({
        queryKey: explanationKeys.single(studentId ?? '', variables.collegeId),
      })
      queryClient.invalidateQueries({
        queryKey: explanationKeys.all(studentId ?? ''),
      })
    },
  })
}

// ============ REGENERATE EXPLANATION ============

export function useRegenerateExplanation(studentId: string | undefined) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      collegeId,
      collegeName,
      onChunk,
    }: {
      collegeId: string
      collegeName: string
      onChunk?: (text: string) => void
    }): Promise<string> => {
      // The POST endpoint already handles regeneration when profile hash differs
      // Force regeneration by always posting
      const res = await fetch('/api/college-explanation', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          studentId,
          collegeId,
          collegeName,
        }),
      })

      if (!res.ok) throw new Error('Failed to regenerate explanation')

      const contentType = res.headers.get('content-type')
      if (contentType?.includes('application/json')) {
        const json = await res.json()
        return json.explanation
      }

      const reader = res.body?.getReader()
      if (!reader) throw new Error('No response body')

      const decoder = new TextDecoder()
      let fullText = ''

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        const chunk = decoder.decode(value, { stream: true })
        fullText += chunk
        onChunk?.(fullText)
      }

      return fullText
    },
    onSuccess: (_data, variables) => {
      queryClient.invalidateQueries({
        queryKey: explanationKeys.single(studentId ?? '', variables.collegeId),
      })
      queryClient.invalidateQueries({
        queryKey: explanationKeys.all(studentId ?? ''),
      })
    },
  })
}
```

---

## 7. Explanation Dialog Component — `components/colleges/CollegeExplanationDialog.tsx`

```typescript
// components/colleges/CollegeExplanationDialog.tsx

'use client'

import React, { useState, useCallback, memo } from 'react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Sparkles, RefreshCw, Loader2, AlertCircle } from 'lucide-react'
import { cn } from '@/lib/utils'
import {
  useCollegeExplanation,
  useGenerateExplanation,
  useRegenerateExplanation,
} from '@/hooks/useCollegeExplanations'

interface CollegeExplanationDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  studentId: string
  collegeId: string
  collegeName: string
}

export const CollegeExplanationDialog = memo(function CollegeExplanationDialog({
  open,
  onOpenChange,
  studentId,
  collegeId,
  collegeName,
}: CollegeExplanationDialogProps) {
  const [streamingText, setStreamingText] = useState<string>('')
  const [isStreaming, setIsStreaming] = useState(false)

  // Fetch cached explanation
  const {
    data: cachedData,
    isLoading: isFetchingCache,
  } = useCollegeExplanation(
    open ? studentId : undefined,
    open ? collegeId : undefined,
  )

  const generateMutation = useGenerateExplanation(studentId)
  const regenerateMutation = useRegenerateExplanation(studentId)

  const handleGenerate = useCallback(async () => {
    setIsStreaming(true)
    setStreamingText('')

    try {
      await generateMutation.mutateAsync({
        collegeId,
        collegeName,
        onChunk: (text) => setStreamingText(text),
      })
    } finally {
      setIsStreaming(false)
    }
  }, [collegeId, collegeName, generateMutation])

  const handleRegenerate = useCallback(async () => {
    setIsStreaming(true)
    setStreamingText('')

    try {
      await regenerateMutation.mutateAsync({
        collegeId,
        collegeName,
        onChunk: (text) => setStreamingText(text),
      })
    } finally {
      setIsStreaming(false)
    }
  }, [collegeId, collegeName, regenerateMutation])

  const hasCachedExplanation = cachedData?.cached && cachedData.explanation
  const displayText = isStreaming ? streamingText : (cachedData?.explanation ?? '')
  const isStale = cachedData?.stale ?? false
  const isLoading = isFetchingCache
  const hasError = generateMutation.isError || regenerateMutation.isError

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[80vh]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Sparkles className="h-5 w-5 text-purple-500" />
            Why {collegeName}?
          </DialogTitle>
          <DialogDescription>
            AI-powered analysis of why this college could be a great fit for you
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          {/* Stale warning */}
          {isStale && !isStreaming && (
            <div className="flex items-center gap-2 rounded-md bg-amber-50 p-3 text-sm text-amber-800 dark:bg-amber-950 dark:text-amber-200">
              <AlertCircle className="h-4 w-4 flex-shrink-0" />
              <span>Your profile has changed since this explanation was generated.</span>
              <Button
                variant="outline"
                size="sm"
                onClick={handleRegenerate}
                disabled={isStreaming}
                className="ml-auto"
              >
                <RefreshCw className="h-3 w-3 mr-1" />
                Update
              </Button>
            </div>
          )}

          {/* Loading state */}
          {isLoading && (
            <div className="flex items-center justify-center py-12">
              <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
            </div>
          )}

          {/* No explanation yet — generate button */}
          {!isLoading && !hasCachedExplanation && !isStreaming && !displayText && (
            <div className="flex flex-col items-center justify-center py-12 space-y-4">
              <Sparkles className="h-12 w-12 text-muted-foreground/50" />
              <p className="text-muted-foreground text-center max-w-sm">
                Generate a personalized explanation of why {collegeName} could be a great fit based on
                your profile, activities, and academic record.
              </p>
              <Button onClick={handleGenerate} disabled={isStreaming}>
                <Sparkles className="h-4 w-4 mr-2" />
                Generate Explanation
              </Button>
            </div>
          )}

          {/* Explanation text */}
          {(displayText || isStreaming) && (
            <ScrollArea className="h-[400px] rounded-md border p-4">
              <div
                className={cn(
                  'prose prose-sm dark:prose-invert max-w-none whitespace-pre-wrap',
                  isStreaming && 'animate-pulse-subtle',
                )}
              >
                {displayText}
                {isStreaming && (
                  <span className="inline-block w-2 h-4 bg-purple-500 animate-pulse ml-0.5" />
                )}
              </div>
            </ScrollArea>
          )}

          {/* Error state */}
          {hasError && !isStreaming && (
            <div className="flex items-center gap-2 rounded-md bg-red-50 p-3 text-sm text-red-800 dark:bg-red-950 dark:text-red-200">
              <AlertCircle className="h-4 w-4 flex-shrink-0" />
              