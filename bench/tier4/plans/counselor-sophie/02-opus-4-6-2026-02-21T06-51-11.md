

# Implementation Plan: Bulk Import Extracurricular Activities from CSV

## Overview

Add a CSV upload feature to the profile page that lets students bulk-import extracurricular activities. The flow: upload CSV → parse & validate with Zod → preview valid/invalid rows → confirm → bulk insert into Supabase `activities` table.

---

## 1. Add Zod Schemas for CSV Validation

**File: `lib/schemas.ts`** (modify — add new schemas at the bottom)

```typescript
// ============ CSV ACTIVITY IMPORT SCHEMAS ============

export const ActivityCategoryEnum = z.enum([
  'Academic',
  'Arts',
  'Athletics',
  'Community Service',
  'Cultural',
  'Leadership',
  'Music',
  'Research',
  'Work Experience',
  'Other',
])

export const CsvActivityRowSchema = z.object({
  name: z
    .string()
    .min(1, 'Activity name is required')
    .max(200, 'Activity name must be under 200 characters'),
  category: ActivityCategoryEnum.catch('Other'),
  hours_per_week: z
    .union([z.string(), z.number()])
    .pipe(z.coerce.number().min(0, 'Hours must be non-negative').max(168, 'Hours cannot exceed 168 per week')),
  description: z.string().max(1000, 'Description must be under 1000 characters').optional().default(''),
})

export type CsvActivityRow = z.infer<typeof CsvActivityRowSchema>

export const CsvActivityImportRequestSchema = z.object({
  student_id: z.string().uuid('Invalid student ID'),
  activities: z.array(CsvActivityRowSchema).min(1, 'At least one activity is required').max(100, 'Cannot import more than 100 activities at once'),
})

export type CsvActivityImportRequest = z.infer<typeof CsvActivityImportRequestSchema>
```

---

## 2. CSV Parsing Utility

**File: `lib/csv.ts`** (create new)

```typescript
export interface CsvParseResult {
  headers: string[]
  rows: Record<string, string>[]
  errors: string[]
}

const EXPECTED_HEADERS = ['name', 'category', 'hours_per_week', 'description']

/**
 * Parse a raw CSV string into an array of row objects.
 * Handles quoted fields, trimming, and header normalization.
 */
export function parseCsvString(raw: string): CsvParseResult {
  const errors: string[] = []
  const lines = raw.split(/\r?\n/).filter((line) => line.trim() !== '')

  if (lines.length === 0) {
    return { headers: [], rows: [], errors: ['CSV file is empty'] }
  }

  // Parse header row
  const rawHeaders = parseCsvLine(lines[0])
  const headers = rawHeaders.map((h) =>
    h
      .trim()
      .toLowerCase()
      .replace(/[\s-]+/g, '_')
      .replace(/[^a-z0-9_]/g, ''),
  )

  // Validate that required headers are present
  const missingHeaders = ['name'].filter((h) => !headers.includes(h))
  if (missingHeaders.length > 0) {
    errors.push(`Missing required column(s): ${missingHeaders.join(', ')}`)
    return { headers, rows: [], errors }
  }

  // Warn about unrecognized headers
  const unrecognized = headers.filter((h) => !EXPECTED_HEADERS.includes(h))
  if (unrecognized.length > 0) {
    errors.push(`Unrecognized column(s) will be ignored: ${unrecognized.join(', ')}`)
  }

  // Parse data rows
  const rows: Record<string, string>[] = []
  for (let i = 1; i < lines.length; i++) {
    const values = parseCsvLine(lines[i])
    const row: Record<string, string> = {}
    headers.forEach((header, idx) => {
      if (EXPECTED_HEADERS.includes(header)) {
        row[header] = (values[idx] || '').trim()
      }
    })
    // Skip completely empty rows
    if (Object.values(row).every((v) => v === '')) continue
    rows.push(row)
  }

  if (rows.length === 0) {
    errors.push('No data rows found in CSV')
  }

  return { headers, rows, errors }
}

/**
 * Parse a single CSV line, respecting quoted fields with commas and escaped quotes.
 */
function parseCsvLine(line: string): string[] {
  const result: string[] = []
  let current = ''
  let inQuotes = false

  for (let i = 0; i < line.length; i++) {
    const char = line[i]
    const next = line[i + 1]

    if (inQuotes) {
      if (char === '"' && next === '"') {
        current += '"'
        i++ // skip escaped quote
      } else if (char === '"') {
        inQuotes = false
      } else {
        current += char
      }
    } else {
      if (char === '"') {
        inQuotes = true
      } else if (char === ',') {
        result.push(current)
        current = ''
      } else {
        current += char
      }
    }
  }
  result.push(current)
  return result
}

/**
 * Generate a template CSV string for download.
 */
export function generateCsvTemplate(): string {
  const header = 'name,category,hours_per_week,description'
  const example1 = 'Debate Club,Academic,5,Varsity debate team captain'
  const example2 = 'Soccer,Athletics,10,JV soccer midfielder'
  const example3 = '"Food Bank Volunteer",Community Service,3,"Weekly volunteer at local food bank, sorting donations"'
  return [header, example1, example2, example3].join('\n')
}
```

---

## 3. API Route for Bulk Insert

**File: `app/api/activities-import/route.ts`** (create new)

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/server'
import { parseRequestBody, CsvActivityImportRequestSchema } from '@/lib/schemas'

export async function POST(request: NextRequest) {
  try {
    // Authenticate the user
    const supabase = await createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Parse and validate request body
    const body = await request.json()
    const parsed = parseRequestBody(CsvActivityImportRequestSchema, body)
    if (!parsed.success) return parsed.response
    const { student_id, activities } = parsed.data

    // Verify the user has access to this student (RLS will also enforce this, but check explicitly)
    const { data: student, error: studentError } = await supabase
      .from('students')
      .select('id')
      .eq('id', student_id)
      .single()

    if (studentError || !student) {
      return NextResponse.json({ error: 'Student not found or access denied' }, { status: 403 })
    }

    // Build rows for insert
    const rows = activities.map((activity, index) => ({
      student_id,
      name: activity.name,
      category: activity.category,
      hours_per_week: activity.hours_per_week,
      description: activity.description || '',
      position: index, // preserve CSV ordering
    }))

    // Bulk insert using the authenticated client (RLS enforced)
    const { data: inserted, error: insertError } = await supabase
      .from('activities')
      .insert(rows)
      .select('id, name, category, hours_per_week, description')

    if (insertError) {
      console.error('Bulk insert error:', insertError)
      return NextResponse.json(
        { error: 'Failed to import activities', details: insertError.message },
        { status: 500 },
      )
    }

    return NextResponse.json({
      success: true,
      imported_count: inserted?.length ?? 0,
      activities: inserted,
    })
  } catch (error) {
    console.error('Activities import error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```

---

## 4. TanStack Query Mutation Hook

**File: `hooks/useActivitiesImport.ts`** (create new)

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { CsvActivityRow } from '@/lib/schemas'

interface ImportActivitiesParams {
  student_id: string
  activities: CsvActivityRow[]
}

interface ImportActivitiesResponse {
  success: boolean
  imported_count: number
  activities: Array<{
    id: string
    name: string
    category: string
    hours_per_week: number
    description: string
  }>
}

async function importActivities(params: ImportActivitiesParams): Promise<ImportActivitiesResponse> {
  const response = await fetch('/api/activities-import', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(params),
  })

  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.error || 'Failed to import activities')
  }

  return response.json()
}

export function useImportActivities(studentId: string | undefined) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: importActivities,
    onSuccess: () => {
      // Invalidate queries that depend on activities data
      // These match the query keys used in useStudentData and useProfileData
      queryClient.invalidateQueries({ queryKey: ['student', studentId] })
      queryClient.invalidateQueries({ queryKey: ['activities', studentId] })
      queryClient.invalidateQueries({ queryKey: ['profile', studentId] })
      queryClient.invalidateQueries({ queryKey: ['dashboard', studentId] })
    },
  })
}
```

---

## 5. CSV Import Preview Component

**File: `components/profile/CsvImportPreview.tsx`** (create new)

```tsx
'use client'

import React, { useMemo } from 'react'
import { CsvActivityRowSchema, CsvActivityRow } from '@/lib/schemas'
import { cn } from '@/lib/utils'
import { CheckCircle2, XCircle, AlertTriangle } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'

interface ParsedRow {
  index: number
  raw: Record<string, string>
  parsed: CsvActivityRow | null
  errors: string[]
}

interface CsvImportPreviewProps {
  rawRows: Record<string, string>[]
  onConfirm: (validActivities: CsvActivityRow[]) => void
  onCancel: () => void
  isImporting: boolean
}

export const CsvImportPreview = React.memo(function CsvImportPreview({
  rawRows,
  onConfirm,
  onCancel,
  isImporting,
}: CsvImportPreviewProps) {
  const parsedRows: ParsedRow[] = useMemo(() => {
    return rawRows.map((raw, index) => {
      const result = CsvActivityRowSchema.safeParse(raw)
      if (result.success) {
        return { index, raw, parsed: result.data, errors: [] }
      }
      const errors = result.error.issues.map((issue) => `${issue.path.join('.')}: ${issue.message}`)
      return { index, raw, parsed: null, errors }
    })
  }, [rawRows])

  const validRows = useMemo(() => parsedRows.filter((r) => r.parsed !== null), [parsedRows])
  const invalidRows = useMemo(() => parsedRows.filter((r) => r.parsed === null), [parsedRows])

  const handleConfirm = () => {
    const activities = validRows.map((r) => r.parsed!).filter(Boolean)
    onConfirm(activities)
  }

  return (
    <div className="space-y-4">
      {/* Summary */}
      <div className="flex items-center gap-4 rounded-lg bg-muted/50 p-4">
        <div className="flex items-center gap-2 text-sm">
          <CheckCircle2 className="h-4 w-4 text-green-600" />
          <span className="font-medium">{validRows.length} valid</span>
        </div>
        {invalidRows.length > 0 && (
          <div className="flex items-center gap-2 text-sm">
            <XCircle className="h-4 w-4 text-red-500" />
            <span className="font-medium">{invalidRows.length} invalid (will be skipped)</span>
          </div>
        )}
        <div className="text-sm text-muted-foreground">Total: {rawRows.length} rows</div>
      </div>

      {/* Preview Table */}
      <div className="max-h-[400px] overflow-auto rounded-md border">
        <table className="w-full text-sm">
          <thead className="sticky top-0 bg-background">
            <tr className="border-b">
              <th className="w-10 px-3 py-2 text-left">#</th>
              <th className="px-3 py-2 text-left">Status</th>
              <th className="px-3 py-2 text-left">Name</th>
              <th className="px-3 py-2 text-left">Category</th>
              <th className="px-3 py-2 text-left">Hours/Week</th>
              <th className="px-3 py-2 text-left">Description</th>
            </tr>
          </thead>
          <tbody>
            {parsedRows.map((row) => (
              <tr
                key={row.index}
                className={cn(
                  'border-b transition-colors',
                  row.parsed ? 'hover:bg-muted/50' : 'bg-red-50 dark:bg-red-950/20',
                )}
              >
                <td className="px-3 py-2 text-muted-foreground">{row.index + 1}</td>
                <td className="px-3 py-2">
                  {row.parsed ? (
                    <CheckCircle2 className="h-4 w-4 text-green-600" />
                  ) : (
                    <div className="group relative">
                      <XCircle className="h-4 w-4 text-red-500" />
                      <div className="absolute left-0 top-6 z-10 hidden w-64 rounded-md border bg-popover p-2 text-xs shadow-md group-hover:block">
                        {row.errors.map((err, i) => (
                          <div key={i} className="text-destructive">
                            {err}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </td>
                <td className="max-w-[200px] truncate px-3 py-2 font-medium">
                  {row.parsed?.name || row.raw.name || '—'}
                </td>
                <td className="px-3 py-2">
                  {row.parsed ? (
                    <Badge variant="secondary" className="text-xs">
                      {row.parsed.category}
                    </Badge>
                  ) : (
                    <span className="text-muted-foreground">{row.raw.category || '—'}</span>
                  )}
                </td>
                <td className="px-3 py-2">{row.parsed?.hours_per_week ?? row.raw.hours_per_week ?? '—'}</td>
                <td className="max-w-[250px] truncate px-3 py-2 text-muted-foreground">
                  {row.parsed?.description || row.raw.description || '—'}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Invalid row errors expanded */}
      {invalidRows.length > 0 && (
        <div className="rounded-md border border-amber-200 bg-amber-50 p-3 dark:border-amber-900 dark:bg-amber-950/30">
          <div className="mb-2 flex items-center gap-2 text-sm font-medium text-amber-800 dark:text-amber-200">
            <AlertTriangle className="h-4 w-4" />
            Rows with errors (will be skipped)
          </div>
          <div className="space-y-1">
            {invalidRows.map((row) => (
              <div key={row.index} className="text-xs text-amber-700 dark:text-amber-300">
                <span className="font-medium">Row {row.index + 1}:</span> {row.errors.join('; ')}
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Actions */}
      <div className="flex items-center justify-end gap-3">
        <Button variant="outline" onClick={onCancel} disabled={isImporting}>
          Cancel
        </Button>
        <Button onClick={handleConfirm} disabled={validRows.length === 0 || isImporting}>
          {isImporting ? (
            <>
              <span className="mr-2 inline-block h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent" />
              Importing...
            </>
          ) : (
            `Import ${validRows.length} ${validRows.length === 1 ? 'Activity' : 'Activities'}`
          )}
        </Button>
      </div>
    </div>
  )
})
```

---

## 6. Main CSV Import Dialog Component

**File: `components/profile/CsvActivityImportDialog.tsx`** (create new)

```tsx
'use client'

import React, { useState, useCallback, useRef } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Upload, Download, FileSpreadsheet } from 'lucide-react'
import { parseCsvString, generateCsvTemplate } from '@/lib/csv'
import { CsvActivityRow } from '@/lib/schemas'
import { useImportActivities } from '@/hooks/useActivitiesImport'
import { CsvImportPreview } from '@/components/profile/CsvImportPreview'
import { useToast } from '@/components/ui/use-toast'

type ImportStep = 'upload' | 'preview' | 'success'

interface CsvActivityImportDialogProps {
  studentId: string
}

export function CsvActivityImportDialog({ studentId }: CsvActivityImportDialogProps) {
  const [open, setOpen] = useState(false)
  const [step, setStep] = useState<ImportStep>('upload')
  const [parsedRows, setParsedRows] = useState<Record<string, string>[]>([])
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [importedCount, setImportedCount] = useState(0)
  const fileInputRef = useRef<HTMLInputElement>(null)
  const importMutation = useImportActivities(studentId)

  // Try to use toast, but fall back gracefully if not available
  let toast: ReturnType<typeof useToast>['toast'] | undefined
  try {
    const toastResult = useToast()
    toast = toastResult.toast
  } catch {
    // toast provider not available
  }

  const resetState = useCallback(() => {
    setStep('upload')
    setParsedRows([])
    setParseErrors([])
    setImportedCount(0)
    importMutation.reset()
    if (fileInputRef.current) {
      fileInputRef.current.value = ''
    }
  }, [importMutation])

  const handleOpenChange = useCallback(
    (isOpen: boolean) => {
      setOpen(isOpen)
      if (!isOpen) {
        resetState()
      }
    },
    [resetState],
  )

  const handleFileSelect = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0]
      if (!file) return

      // Validate file type
      if (!file.name.endsWith('.csv') && file.type !== 'text/csv') {
        setParseErrors(['Please select a CSV file'])
        return
      }

      // Validate file size (max 1MB)
      if (file.size > 1024 * 1024) {
        setParseErrors(['File is too large. Maximum size is 1MB.'])
        return
      }

      const reader = new FileReader()
      reader.onload = (e) => {
        const text = e.target?.result as string
        const result = parseCsvString(text)

        if (result.errors.length > 0 && result.rows.length === 0) {
          setParseErrors(result.errors)
          return
        }

        // Non-fatal warnings still pass through
        setParseErrors(result.errors.filter((e) => e.startsWith('Unrecognized')))
        setParsedRows(result.rows)
        setStep('preview')
      }
      reader.onerror = () => {
        setParseErrors(['Failed to read file. Please try again.'])
      }
      reader.readAsText(file)
    },
    [],
  )

  const handleDrop = useCallback(
    (event: React.DragEvent<HTMLDivElement>) => {
      event.preventDefault()
      const file = event.dataTransfer.files[0]
      if (file) {
        // Create a synthetic change event by setting the file input
        const dataTransfer = new DataTransfer()
        dataTransfer.items.add(file)
        if (fileInputRef.current) {
          fileInputRef.current.files = dataTransfer.files
          const changeEvent = new Event('change', { bubbles: true })
          fileInputRef.current.dispatchEvent(changeEvent)
          // Manually trigger since synthetic events won't call React handler
          handleFileSelect({
            target: { files: dataTransfer.files },
          } as React.ChangeEvent<HTMLInputElement>)
        }
      }
    },
    [handleFileSelect],
  )

  const handleDragOver = useCallback((event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault()
  }, [])

  const handleConfirmImport = useCallback(
    (validActivities: CsvActivityRow[]) => {
      importMutation.mutate(
        { student_id: studentId, activities: validActivities },
        {
          onSuccess: (data) => {
            setImportedCount(data.imported_count)
            setStep('success')
            toast?.({
              title: 'Activities imported',
              description: `Successfully imported ${data.imported_count} activities.`,
            })
          },
          onError: (error) => {
            toast?.({
              title: 'Import failed',
              description: error.message,
              variant: 'destructive',
            })
          },
        },
      )
    },
    [studentId, importMutation, toast],
  )

  const handleDownloadTemplate = useCallback(() => {
    const csv = generateCsvTemplate()
    const blob = new Blob([csv], { type: 'text/csv' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = 'activities_template.csv'
    a.click()
    URL.revokeObjectURL(url)
  }, [])

  return (
    <Dialog open={open} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>
        <Button variant="outline" size="sm" className="gap-2">
          <Upload className="h-4 w-4" />
          Import CSV
        </Button>
      </DialogTrigger>
      <DialogContent className="max-w-3xl">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <FileSpreadsheet className="h-5 w-5" />
            Import Activities from CSV
          </DialogTitle>
          <DialogDescription>
            Upload a CSV file to bulk-import extracurricular activities.
          </DialogDescription>
        </DialogHeader>

        {/* ============ UPLOAD STEP ============ */}
        {step === 'upload' && (
          <div className="space-y-4">
            {/* Drop zone */}
            <div
              onDrop={handleDrop}
              onDragOver={handleDragOver}
              className="flex cursor-pointer flex-col items-center justify-center gap-3 rounded-lg border-2 border-dashed border-muted-foreground/25 p-8 transition-colors hover:border-muted-foreground/50"
              onClick={() => fileInputRef.current?.click()}
            >
              <Upload className="h-8 w-8 text-muted-foreground" />
              <div className="text-center">
                <p className="text-sm font-medium">Drop your CSV file here, or click to browse</p>
                <p className="mt-1 text-xs text-muted-foreground">Maximum file size: 1MB • Maximum 100 activities</p>
              </div>
              <input
                ref={fileInputRef}
                type="file"
                accept=".csv,text/csv"
                onChange={handleFileSelect}
                className="hidden"
              />
            </div>

            {/* Parse errors */}
            {parseErrors.length > 0 && (
              <div className="rounded-md border border-destructive/50 bg-destructive/10 p-3">
                {parseErrors.map((error, i) => (
                  <p key={i} className="text-sm text-destructive">
                    {error}
                  </p>
                ))}
              </div>
            )}

            {/* Template download */}
            <div className="flex items-center justify-between rounded-lg bg-muted/50 p-4">
              <div>
                <p className="text-sm font-medium">Need a template?</p>
                <p className="text-xs text-muted-foreground">
                  Download a CSV template with example data and expected columns.
                </p>
              </div>
              <Button variant="ghost" size="sm" onClick={handleDownloadTemplate} className="gap-2">
                <Download className="h-4 w-4" />
                Download Template
              </Button>
            </div>

            {/* Expected format */}
            <div className="text-xs text-muted-foreground">
              <p className="mb-1 font-medium">Expected columns:</p>
              <ul className="list-inside list-disc space-y-0.5">
                <li>
                  <strong>name</strong> (required) — Activity name
                </li>
                <li>
                  <strong>category</strong> — Academic, Arts, Athletics, Community Service, Cultural, Leadership, Music,
                  Research, Work Experience, or Other
                </li>
                <li>
                  <strong>hours_per_week</strong> — Numeric hours (0–168)
                </li>
                <li>
                  <strong>description</strong> — Brief description of the activity
                </li>
              </ul>
            </div>
          </div>
        )}

        {/* ============ PREVIEW STEP ============ */}
        {step === 'preview' && (
          <CsvImportPreview
            rawRows={parsedRows}
            onConfirm={handleConfirmImport}
            onCancel={resetState}
            isImporting={importMutation.isPending}
          />
        )}

        {/* ============ SUCCESS STEP ============ */}
        {step === 'success' && (
          <div className="flex flex-col items-center gap-4 py-8">
            <div className="flex h-16 w-16 items-center justify-center rounded-full bg-green-100 dark:bg-green-900/30">
              <FileSpreadsheet className="h-8 w-8 text-green-600" />
            </div>
            <div className="text-center">
              <h3 className="text-lg font-semibold">Import Complete!</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Successfully imported {importedCount} {importedCount === 1 ? 'activity' : 'activities'}.
              </p>
            </div>
            <Button onClick={() => handleOpenChange(false)}>Done</Button>
          </div>
        )}
      </DialogContent>
    </Dialog>
  )
}
```

---

## 7. Integrate into Profile Page

**File: `app/(dashboard)/profile/page.tsx`** (modify)

Add the import button to the Activities section (Section 1 — Overview). Locate the area where activities are rendered and add the import dialog trigger next to any existing "Add Activity" button.

```tsx
// Add import at the top of the file
import { CsvActivityImportDialog } from '@/components/profile/CsvActivityImportDialog'

// ... inside the component, in the Overview / Activities section header area,
// find where activities are listed and add the import button.

// Example insertion point — look for the Activities section header:
// Before:
//   <h3 className="...">Activities</h3>
//   <Button onClick={handleAddActivity}>Add Activity</Button>

// After:
//   <h3 className="...">Activities</h3>
//   <div className="flex items-center gap-2">
//     <CsvActivityImportDialog studentId={studentId} />
//     <Button onClick={handleAddActivity}>Add Activity</Button>
//   </div>
```

More specifically, search for the "Activities" heading in the existing file and wrap the action buttons:

```tsx
// In the section that renders activities, modify the header area:
<div className="flex items-center justify-between">
  <h3 className="text-lg font-semibold">Activities</h3>
  <div className="flex items-center gap-2">
    <CsvActivityImportDialog studentId={studentId} />
    {/* existing Add Activity button remains here */}
  </div>
</div>
```

The `studentId` should already be available in the profile page from the student data query — it's typically sourced from `useStudentData()` or similar.

---

## 8. Add Zustand Selector (if needed)

**File: `store/index.ts`** (modify — add if not already present)

If there isn't already a granular selector for activities-related UI state (like a modal), add:

```typescript
// ============ CSV IMPORT STATE ============
// Add to the store interface
csvImportOpen: boolean
setCsvImportOpen: (open: boolean) => void

// Add to the store create
csvImportOpen: false,
setCsvImportOpen: (open) => set({ csvImportOpen: open }),

// Add granular selector
export const useCsvImportOpen = () => useStore((s) => s.csvImportOpen)
export const useSetCsvImportOpen = () => useStore((s) => s.setC